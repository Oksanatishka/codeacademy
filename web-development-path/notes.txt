- https://www.codecademy.com/learn/paths/web-development
- Cheatsheet https://www.codecademy.com/learn/paths/web-development/tracks/learn-html-web-dev-path/modules/learn-html-tables/cheatsheet
- Guide: How to Become a Web Developer https://discuss.codecademy.com/t/guide-how-to-become-a-web-developer/394722
30 weeks
----------------------------------------------------------------------------------------------------
1. Learn HTML
    > Elements and Structure
        Project: Fashion Blog (Inspect html) https://s3.amazonaws.com/codecademy-content/courses/learn-html/elements-and-structure/fashion.html
        
        HTML Anatomy
        The Body
        HTML Structure
        Headings
        Divs
        Attributes
        Displaying Text
        Styling Text
        Line Breaks
        Unordered Lists / Ordered Lists
        Images, Image Alts
        Videos

        HTML DOCUMENT STANDARDS
            The <html> tag
            The Head
            Page Titles
            Linking to Other Web Pages
            Opening Links in a New Window
            Linking to Relative Page
            Linking At Will
            Linking to Same Page (anchor)
            Whitespace and indentation // to visualize the relationship between elements
            Comments
            HTML Tags

    > Tables
        Project: Wine Festival Schedule https://s3.amazonaws.com/codecademy-content/courses/learn-html-tables/index.html

        Create a Table
        Table Rows
        Table Data
        Table Headings
        Table Borders
        Spanning Columns & Spanning Rows
        Table Body
        Table Head
        Table Footer
        Styling with CSS

    > Forms
        Project: Form a Story

        Text Input
        Adding a Label
        Password Input
        Number Input
        Range Input
        Checkbox Input
        Radio Button Input
        Dropdown list
        Datalist Input
        Textarea element
        Submit Form

        FORM VALIDATION
            - server-side validation
            - client-side validation 
                Requiring an Input  // required attribute
                Set a Minimum and Maximum   // min, max attributes
                Checking Text Length    // minlength, maxlength attributes
                Matching a Pattern  // use pattern attribute and assign it regex

    > Learn Semantic HTML
        Project: New York City Blog

        When building web pages, we use a combination of non-semantic HTML and Semantic HTML. 
        The word semantic means “relating to meaning,” so semantic elements provide information about the content between the opening and closing tags.
        Elements such as <div> and <span> are not semantic elements since they provide no context as to what is inside of those tags.
        Why use Semantic HTML?  - Accessibility, SEO, Easy to Understand.
        <header>, <nav> , <main> and <footer> create the basic structure of the webpage.

        SEMANTIC HTML   // modern standard
            - Header and Nav: <header>, <nav>
                <header> 
                    <nav>
                        <ul>
                            <li><a href="#home">Home</a></li>
                            <li><a href="#about">About</a></li>      
                        </ul>
                    </nav>
                </header>
            - Main and Footer: <main>, <footer>
                <main>
                    <header><h1>Types of Sports</h1></header>
                    <article><h3>Baseball</h3><p>The first game of baseball was played in Cooperstown, New York in the summer of 1839.</p></article>
                </main>
                The footer contains information such as:
                    - Contact information
                    - Copyright information
                    - Terms of use
                    - Site Map
                    - Reference to top of page links
            - Article and Section: <section>, <article>
                <article> can hold content such as articles, blogs, comments, magazines, etc. 
            - The Aside Element: <aside>
                Some common uses of the <aside> element are for:
                    - Bibliographies
                    - Endnotes
                    - Comments
                    - Pull quotes
                    - Editorial sidebars
                    - Additional information
            - Figure and Figcaption: <figure>, <figcaption>
                <figure> is an element used to encapsulate media such as an image, illustration, diagram, code snippet, etc, which is referenced in the main flow of the document.
                <figcaption> is an element used to describe the media in the <figure> tag.
                    <figure>
                        <img src="overwatch.jpg"/>
                        <figcaption>This picture shows characters from Overwatch.</figcaption>
                    </figure>
            - Audio and Attributes
            - Video and Embed

************************************************************************************************
************************************************************************************************
************************************************************************************************
2. Styling a Website
    > Selectors and Visual Rules
        Project: Healthy Recipes
        Project: Olivia Woodruff Portfolio

        CSS SETUP AND SELECTORS
            Inline Styles
            The <style> Tag
            The .css file
            Linking the CSS File
            Tag Name, Class Name, Multiple Classes, ID Name, Classes and IDs
            Specificity  
                It's the order by which the browser decides which CSS styles will be displayed.
                IDs -> classes -> tags.
            Chaining Selectors
            Nested Elements
            Important   // it’s best to avoid !important -> reorganize CSS
            Multiple Selectors
        
        CSS VISUAL RULES
            CSS Structure
            Font Family
            Font Size
            Font Weight
            Text Align
            Color
            Opacity
            Background Image

    > Local Website Development
        setup with text editors: Visual Studio Code / Atom
            we recommend naming directory 'projects' to store all of your coding projects.
            debugging https://code.visualstudio.com/docs/editor/debugging
        Chrome Devtools to inspect HTML and CSS in websites
        
************************************************************************************************
************************************************************************************************
************************************************************************************************
3. Getting Started with JavaScript
    Console
    Comments
    Data Types (7):
        primitive - Number, String, Boolean, Null, Undefined, Symbol, 
        more complex - Object.
    Arithmetic Operators: + - * / %
    String Concatenation (using +)
    Properties
    Methods
        syntax: 'example string'.methodName()
    Built-in Objects
        e.g. Math.floor((Math.random() * 50);    // To generate a random number between 0 and 50, we could multiply this result by 50

    Variables: var, let, const
        const variable cannot be reassigned because it is constant. If you try to reassign a const variable, you’ll get a TypeError.
        Constant variables must be assigned a value when declared. If you try to declare a const variable without a value, you’ll get a SyntaxError.
        
        Mathematical Assignment Operators    
        The Increment and Decrement Operator
        String Interpolation    //  to insert, or interpolate, variables into strings using template literals. 
        typeof operator
    
    JS Versions: ES6 and Before

    Conditional Statements
        - if, else if, and else statements
        - comparison operators: <, >, <=, >=, ===, !==
        - logical operators: &&, ||, !, 
        - truthy vs falsy values, Truthy and Falsy Assignment
            falsy values: 
                - 0
                - Empty strings like "" or ''
                - null 
                - undefined 
                - NaN
        - ternary operators
        - switch statement

    Functions
        Function Declarations: function funcName() {}
            hoisting    // allows access to function declarations before they’re defined. It isn’t considered good practice
        Calling a Function  // The code inside a function body runs, or executes, only when the function is called. 
        Parameters and Arguments
            function funcName(parameters) {}
            funcName(arguments);
        Default Parameters
        Return  // By default that resulting value is undefined. To pass back information from the function call, we use a return statement. 
        Helper Functions
        Function Expressions: const calculate = function() {}   // anonymous function, the function name is usually omitted
        Arrow Functions: const calculate = () => {}
        Concise Body Arrow Functions
            JavaScript also provides several ways to refactor arrow function syntax.
            - zero parameter: e.g. const calculate = () => {}
                one parameter: e.g. const calculate = param1 => {}
                two or more parameters: e.g. const calculate = (param1, param2) => {}
            - implicit return
                single-line block, e.g. const sum = num => num + num;
                multi-line block, e.g. const sum = num => {const sum = num + num; return sum; };
        
************************************************************************************************
************************************************************************************************
************************************************************************************************
4. Getting More Advanced with Design
    Box Model components:
        - content container with width & height (dimensions of an element’s box)
        - paddings
        - borders
        - margins
            div {margin: 0 auto;}   // to center content, also add 'width'.

        Total dimensions = sum of vertical dimensions X sum of horizontal dimensions.

        Resetting Defaults:
        All major web browsers have a default stylesheet they use in the absence of an external stylesheet. 
        These default stylesheets are known as 'user agent' stylesheets. 
        Many developers choose to reset these default values:
            * {
                margin: 0;
                padding: 0;
            }

        CSS properties:
            - min-width / max-width
            - overflow: hidden / scroll / visible
            - visibility: hidden / visible    // It will still leave an empty space where the element is intended to display.
    
    CHANGING THE BOX MODEL      
        Default
            box-sizing: content-box;        // the default box model, box dimensions are affected by border thickness and padding.
        To reset the entire box model:
            * {
                box-sizing: border-box;     // to avoid the dimensional issues that exist in the default box model (means the overall dimensions of the box do not change).
            }
        
        DevTools: Elements -> 'Computed' tab on the top of the rightmost column. 

    CSS Display and Positioning
        CSS properties:
            - position: static(default) / relative / absolute / fixed
                relative    // offset properties: top / bottom / left / right
                absolute    // all other elements on the page will ignore the element and act like it is not present on the page. The element will be positioned relative to its closest positioned parent element.
                fixed       // This technique is often used for navigation bars on a web page. The element is removed from the flow of the html document.
            - display: inline / block / inline-block
            - z-index
            - float: left / right
            - clear: left / right / both / none     // when multiple floated elements have different heights, it can affect their layout on the page. 

    CSS COLOR
        - Named colors (147)
        - hex colors: e.g. #A0522D
        - RGB (256 * 256 * 256 = 16,777,216) + opacity
        - HSL   + opacity

        Foreground color - is the color that an element appears in. 
        Background color - e.g. when a heading is styled so that its background appears yellow.

        CSS properties:
            - color
            - background-color
        opacity
    
    CSS TYPOGRAPHY
        Font Family (or typeface)
            The default typeface for many browsers is Times New Roman. 
            It’s a good practice to limit the number of typefaces used on a web page to 2 or 3.
        Fallback Fonts: Serif / Sans-Serif
            e.g. font-family: "Garamond", "Times", serif;
        Linking Non-user fonts, e.g.Google Fonts, https://www.fontsquirrel.com/
            <link href="https://fonts.googleapis.com/css?family=Droid+Serif" type="text/css" rel="stylesheet">
            @font-face
                @font-face {
                    font-family: "Roboto";
                    src: url(fonts/Roboto.woff2) format('woff2'),
                        url(fonts/Roboto.woff) format('woff'),
                        url(fonts/Roboto.tff) format('truetype');
                }
        CSS properties:
            - font-family
                font-family: Garamond;
                font-family: "Courier New";             // When the name of a typeface consists of more than one word, it must be enclosed in double quotes (otherwise it will not be recognized)
            - font-weight: normal / bold / 100-900      // 400 is the default font-weight of most text.
            - font-style: normal / italic
            - word-spacing  // The default amount of space between words is usually 0.25em.
            - letter-spacing
            - text-transform: uppercase / lowercase
            - text-align: right / left / center
            - line-height

        Responsive Design
            - hard coded measurements: px
            - relative measurements: 
                - em  // represents the size of the base font being used.
                    16 pixels is normally the default size of text in a browser.
                    if the base font is 16 pixels, then 1 em is equal to 16 pixels. 2 ems would equal 32 pixels, and so on.

                    .splash-section {font-size: 18px;}
                    .splash-section h1 {font-size: 1.5em;}

                - rem (root em) // It acts similar to em, but instead of checking parent elements to size font, it checks the root element. The root element is the <html> tag.
                    Most browsers set the font size of <html> to 16 pixels, so by default rem measurements will be compared to that value. 
                    One advantage of using rems is that all elements are compared to the same font size value, making it easy to predict how large or small font will appear.
                    
                    If you are interested in sizing elements consistently across an entire website, the rem measurement is the best unit for the job. 
                    If you’re interested in sizing elements in comparison to other elements nearby, then the em unit would be better suited for the job.
                    
                    html {font-size: 20px;}
                    h1 {font-size: 2rem;}
                
                - percentages   // To size non-text HTML elements relative to their parent elements on the page you can use percentages.
                    Percentages are often used to size box-model values, like width and height, padding, border, and margins. 
                    They can also be used to set positioning properties (top, bottom, left, right).

                    .main {height: 300px; width: 500px;}
                    .main .subsection {height: 50%; width: 50%;}

                Keep in mind: min-width / max-width, min-height / max-height
                Scaling Background Images
                    body {
                        background-image: url('#');
                        background-repeat: no-repeat;
                        background-position: center;
                        background-size: cover;
                    }
            MEDIA QUERIES
                Dots Per Inch (DPI)
                    screen resolution
                    Many times we will want to supply higher quality media (images, video, etc.) only to users with screens that can support high resolution media.
                    Targeting screen resolution also helps users avoid downloading high resolution (large file size) images that their screen may not be able to properly display.
                    
                    To target by resolution, we can use the min-resolution and max-resolution media features. 
                    These media features accept a resolution value in either dots per inch (dpi) or dots per centimeter (dpc).
                        @media only screen and (min-resolution: 300dpi) {
                            /* CSS for high resolution screens */
                        }
                
                Breakpoints
                    The points at which media queries are set are called breakpoints.
                    - tablets in landscape orientation:
                        @media only screen and (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
                            /* CSS ruleset */
                        }
                    Rather than set breakpoints based on specific devices, the best practice is to resize your browser to 
                    view where the website naturally breaks based on its content. 
                    The dimensions at which the layout breaks or looks odd become your media query breakpoints.
                    
                    List of breakpoints by device widths:
                        desktop > 1600px
                        laptop <=1600px
                        tablet landscape <=1024px
                        tablet <=768px
                        mobile <=480px

        Flexbox     // a new tool developed for CSS3 that greatly simplifies how to position elements.
            While flexbox is not meant to lay out entire pages, it is useful for positioning elements, whether individually or in groups.
            There are two important components to a flexbox layout: 
                - flex containers   // element that contains flex items. All direct child elements of a flex container are flex items.
                    display: flex (block level element) / inline-flex (inline elements)
                - flex items:
                    justify-content: flex-start / flex-end / center / space-around / space-between  // To position the items from left to right
                    align-items: flex-start / flex-end / center / baseline / stretch // To align flex items vertically
                    
                    flex-grow
                    flex-shrink
                    flex-basis
                    flex
                    flex-wrap
                    align-content
                    flex-direction
                    flex-flow

        Design Spec, example: https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-4/img-tea-cozy-redline.jpg
            Provide a design spec and image assets.
            A design spec is an image of a web page outlined with all of its CSS properties and values. These are usually created by a designer as a source of instructions for a web developer.

************************************************************************************************
************************************************************************************************
************************************************************************************************
5. JavaScript: Arrays, Loops, and Objects
    Scope
        A block is the code found inside a set of curly braces {}. 
        We say that variable has block scope because it is only accessible to the lines of code within that block. Variables that are declared with block scope are known as local variables because they are only available to the code that is part of the same block.
        In global scope, variables are declared outside of blocks. These variables are called global variables.
            When you declare global variables, they go to the global namespace. 
        Scope pollution is when we have too many global variables that exist in the global namespace, or when we reuse variables across different scopes. 

    Arrays
        To create array:
            - array literal     []
            - 
        To access element:
            - using index
        To update element.
        Length: 
            - .length property
        Methods:
            - .push() - .pop()
            - .unshift() - .shift()
            - .join(), .slice(), .splice(), and .concat()
        
        Variables declared with let can be reassigned.
        Elements in an array declared with const remain mutable. Meaning that we can change the contents of a const array, but cannot reassign a new array or a different value.

        When an array contains another array it is known as a nested array. 
            To access the nested arrays: 
                - bracket notation with the index value, e.g. nestedArr[1] or nestedArr[1][0]
    
    Loops
        iterate simply means “to repeat”.
        - for
        - while
        - do..while
        
        nested loop
        break;
    
    HOF (HIGHER-ORDER FUNCTIONS)
        Higher-order functions are functions that accept other functions as arguments and/or return functions as output. This enables us to build abstractions on other abstractions, just like “We hosted a birthday party” is an abstraction that may build on the abstraction “We made a cake.”
        HOF is a function that either accepts functions as parameters, returns a function, or both!

        Functions as Data
            // we have an annoyingly long function name
            const announceThatIAmDoingImportantWork = () => {
                console.log("I’m doing very important work!");
            };
            // rename this function, re-assign the function to a variable with a suitably short name
            const busy = announceThatIAmDoingImportantWork;     //  !! without parentheses
            busy();

            busy is a variable that holds a reference to our original function. If we could look up the address in memory of busy and the address in memory of announceThatIAmDoingImportantWork they would point to the same place. 
            Our new busy() function can be invoked with parentheses as if that was the name we originally gave our function.
            Notice how we assign announceThatIAmDoingImportantWork without parentheses as the value to the busy variable. We want to assign the value of the function itself, not the value it returns when invoked.

        Functions as Parameters
            We call the functions that get passed in as parameters and invoked callback functions because they get called during the execution of the higher-order function.
            When we pass a function in as an argument to another function, we don’t invoke it. Anonymous functions can be arguments too!

                const timeFuncRuntime = funcParameter => {      // takes in a function as an argument
                   let t1 = Date.now();                         // saves a starting time
                   funcParameter();                             // invokes the callback function
                   let t2 = Date.now();                         // records the time after the function was called
                   return t2 - t1;                              // returns the time the function took to run by subtracting the starting time from the ending time.
                }
                const addOneToOne = () => 1 + 1;
                timeFuncRuntime(addOneToOne);       // timeFuncRuntime() is HOF
            
    Iterators
        The built-in JavaScript array methods that help us iterate are called iteration methods, at times referred to as iterators.
        Iterators are methods called on arrays to manipulate elements and return values.
            .forEach()      // loops through the array and executes the callback function for each element.
                                The return value for .forEach() will always be undefined.
            .map()          // it takes an argument of a callback function and returns a new array
            .filter()       // returns a new array, the callback function for the .filter() method should return true or false depending on the element that is passed to it. 

            .findIndex()    // return the index of the first element that evaluates to true in the callback function.
            .reduce()       // returns a single value after iterating through the elements of an array, thereby reducing the array.
                arr.reduce((accumulator, currentValue) => {return accumulator + currentValue})
            .some()         // return a boolean value
            .every()        // return a boolean value
        
        Linting - a process by which text is evaluated and improved by an application.
        Other methods: .split(' ')

    Objects
        object literal {}, data is organized into key-value pairs.
        A key’s value can be of any data type in the language including functions or other objects.
        To access an object’s property: 
            - dot notation. 
            - Bracket Notation: ['A', 'B', 'C'][0]; // Returns 'A'. We *must* use bracket notation when accessing keys that have numbers, spaces, or special characters in them. 
        Methods:
            - 'Math' is also a global javascript object and '.floor()' is a method on it.
            - 'console' is a global javascript object and '.log()' is a method on that object. 
        Nested Objects.
        Looping Through Objects: for...in
    
    Advanced Objects:
        > 'this' keyword.
                const robot = {
                    model: '1E78V2',
                    provideInfo(){
                        return `I am ${this.model}.`    // 'this.model' is the same as 'robot.model'
                    },
                    // this & issue with arrow fn:
                    diet: () => {
                        console.log(this.model);    // robot.diet(); will print undefined
                        // Arrow functions inherently bind, or tie, an already defined this value to the function itself that is NOT the calling object. In the code snippet above, the value of this is the global object, or an object that exists in the global scope, which doesn’t have a dietType property and therefore returns undefined.
                        // !! Avoid using arrow functions when using 'this' in a method!
                    }
                };
        > conveying privacy in JavaScript methods.
            Certain languages have privacy built-in for objects, but JavaScript does not have this feature. 
            Rather, JavaScript developers follow naming conventions that signal to other developers how to interact with a property. 
            One common convention is to place an underscore _ before the name of a property to mean that the property should not be altered. 
                const bankAccount = {
                    _amount: 1000       // _amount is not intended to be directly manipulated.
                }
                bankAccount._amount = 1000000;  // Even so, it is still possible to reassign _amount.
            In later exercises, we’ll cover the use of methods called getters and setters. Both methods are used to respect the intention of properties prepended, or began, with _. 
        > defining getters and setters in objects.
            Getters are methods that get and return the internal properties of an object.
            Another thing to keep in mind when using getter (and setter) methods is that properties cannot share the same name as the getter/setter function. If we do so, then calling the method will result in an infinite call stack error. One workaround is to add an underscore before the property name like we did in the example above.

                const person = {
                    _firstName: 'John',
                    _lastName: 'Doe',
                    get fullName() {
                        if (this._firstName && this._lastName){
                          return `${this._firstName} ${this._lastName}`;
                        } else {
                          return 'Missing a first name or a last name.';
                        }
                    }
                }
                person.fullName; // 'John Doe'  // To call the getter method (!!without ()): 

            Setter methods reassign values of existing properties within an object.
                const person = {
                    _age: 37,
                    set age(newAge){
                        if (typeof newAge === 'number'){
                            this._age = newAge;
                        } else {
                            console.log('You must assign a number to age');
                        }
                    }
                };
                person.age = 100
            Like getter methods, there are similar advantages to using setter methods that include checking input, performing actions on properties, and displaying a clear intention for how the object is supposed to be used. 
            Nonetheless, even with a setter method, it is still possible to directly reassign properties. 
                person._age = 'forty-five'
                console.log(person._age); // Prints forty-five

        > creating factory functions.
            When we want to create many instances of an object quickly -> factory functions.
            A factory function is a function that returns an object and can be reused to make multiple object instances. Factory functions can also have parameters allowing us to customize the object that gets returned.
            e.g. With 'monsterFactory' in place, we don’t have to create an object literal every time we need a new monster. Instead, we can invoke the monsterFactory function with the necessary arguments to make a monster for us!

                const monsterFactory = (name, age, energySource, catchPhrase) => {
                    return { 
                        name: name,
                        age: age, 
                        energySource: energySource,
                        scare() {
                            console.log(catchPhrase);
                        } 
                    }
                };
                const ghost = monsterFactory('Ghouly', 251, 'ectoplasm', 'BOO!');
                ghost.scare(); // 'BOO!'

        > using destructuring techniques.
            ES6 introduced some new shortcuts for assigning properties to variables known as destructuring.
            Destructuring techniques:
                - property value shorthand:
                    const monsterFactory = (name, age) => {
                        return { 
                            name,
                            age 
                        }
                    };
                
                - destructured assignment:
                    const vampire = {
                        residence: 'Transylvania',
                        preferences: {
                            day: 'stay inside'
                        }
                    };
                    const residence = vampire.residence; 
                    console.log(residence); // Prints 'Transylvania' 

                    // Instead:
                    const { residence } = vampire; 
                    console.log(residence); // Prints 'Transylvania'

                    const { day } = vampire.preferences;    // We can even use destructured assignment to grab nested properties of an object.
                    console.log(day); // Prints 'stay inside'

        Built-in Object Methods: .hasOwnProperty(), .valueOf(), ...
            Object class methods: Object.assign(), Object.entries(), and Object.keys()

    Re-creating the Lodash Library
        Project: Lodash
            Library documentation: https://lodash.com/docs/4.17.15
************************************************************************************************
************************************************************************************************
************************************************************************************************
6. Building Interactive JavaScript Websites
    The HTML parser does NOT process the next element in the HTML file until it loads and executes the <script> element, thus leading to a delay in load time and resulting in a poor user experience.
    Additionally, scripts are loaded sequentially, so if one script depends on another script, they should be placed in that very order inside the HTML file.
    HTML4 introduced the 'defer' and 'async' attributes of the <script> element to address the user wait-time in the website based on different scenarios.
    
    - defer attribute - specifies scripts should be executed after the HTML file is completely parsed.
        When the HTML parser encounters a <script> element with the defer attribute, it loads the script but defers the actual execution of the JavaScript until after it finishes parsing the rest of the elements in the HTML file.
        <script src="example.js" defer></script> 
        When is defer useful?   - When a script contains functionality that requires interaction with the DOM, the defer attribute is the way to go. This way, it ensures that the entire HTML file has been parsed before the script is executed.
    - async attribute - loads and executes the script asynchronously with the rest of the webpage. This means that, similar to the defer attribute, the HTML parser will continue parsing the rest of the HTML as the script is downloaded in the background. However, with the async attribute, the script will not wait until the entire page is parsed: it will execute immediately after it has been downloaded. 
        <script src="example.js" async></script>
        When is it useful? - async is useful for scripts that are independent of other scripts in order to function accordingly. Thus, if it does not matter exactly at which point the script file is executed, asynchronous loading is the most suitable option as it optimizes web page load time.    
    - The old convention was to put scripts right before the </body> tag to prevent the script from blocking the rest of the HTML content. Now, the convention is to put the script tag in the <head> element and to use the defer and async attributes.

    DOM
        The Document Object Model, abbreviated DOM, is a powerful tree-like structure that allows programmers to conceptualize hierarchy and access the elements on a web page.
        The DOM is a logical tree-like Model that organizes a web page’s HTML Document as an Object.
        In the DOM tree, the top-most node is called the root node, and it represents the HTML document. The descendants of the root node are the HTML tags in the document, starting with the <html> tag followed by the <head> and <body> tags and so on.
            A parent node is the closest connected node to another node in the direction towards the root.
            A child node is the closest connected node to another node in the direction away from the root.
                document    // root node
                    |
                   html
                  |     |
                head    body
            
            There are nine different types of node objects in the DOM tree. In our diagram, the node objects with the sharp-edge rectangles are of the type 'Element', while the rounded edge rectangles are of type 'Text', because they represent the text inside the HTML paragraph elements.
            When trying to modify a web page, the script will mostly interact with the DOM nodes of type 'element'.
            DOM allows us to access a node’s attributes, such as its class, id, and inline style.
            
            The 'document' object in JavaScript is the door to the DOM structure. 
                - document.body
                - document.title
                - document.head
                - other https://developer.mozilla.org/en-US/docs/Web/API/Document

                You can access and set the contents of an element with the .innerHTML property.
                    document.body.innerHTML = 'The cat loves the dog.';
                    document.body.innerHTML = '<h2>This is a heading</h2>';

            The DOM interface allows us to access a specific element with CSS selectors.
                document.querySelector('p');    // The .querySelector() method allows us to specify a CSS selector and then returns the first element that matches that selector. 
                document.getElementById('bio').innerHTML = 'The description';
            
            Style:
                let blueElement = document.querySelector('.blue');
                blueElement.style.backgroundColor = 'blue';

                document.querySelector('.blue').style.fontFamily = 'Roboto';

            Create and Insert Elements
                let paragraph = document.createElement('p');
                paragraph.id = 'info'; 
                paragraph.innerHTML = 'The text inside the paragraph';
                document.body.appendChild(paragraph);

                Unlike the .innerHTML property, the .appendChild() method does not replace the content inside of the parent, in this case body. Rather, it appends the element as the last child of that parent.

            Remove an Element
                let paragraph = document.querySelector('p');    // to remove
                document.body.removeChild(paragraph);

                document.getElementById('sign').hidden = true;  // to hide 

            Interactivity with onclick
                let element = document.getElementById('interact');
                element.onclick = function() { element.style.backgroundColor = 'blue' };

        DOM EVENTS WITH JAVASCRIPT
            After a specific event fires on a specific element in the document object model (or DOM), an 'event handler function' can be created to run as a response. 
            JavaScript interprets registered events as event objects with properties and methods. 

            It’s best practice to create named event handler functions, instead of anonymous functions. 
                let eventHandlerFunction = function() {// this block of code will run}
                eventTarget.onclick = eventHandlerFunction;
            
            The .addEventListener() method is another common syntax for registering event handlers. 
                eventTarget.addEventListener('click', eventHandlerFunction);

            The .removeEventListener() method is used to reverse the .addEventListener() method. 
                eventTarget.removeEventListener('click', eventHandlerFunction);
            
            Event Object Properties
                .target property to access the element that triggered the event.
                .type property to access the name of the event.
                .timeStamp property to access the number of milliseconds that passed since the document loaded and the event was triggered.

                let sharePhoto = function(event) {
                  event.target.style.display = 'none';
                  text.innerHTML = 'You share the puppy in ' + event.timeStamp + ' ms.';
                }
                share.onclick = sharePhoto;

            Event Types https://developer.mozilla.org/en-US/docs/Web/Events
                - 
                - mouse events
                - keyboard

        HANDLEBARS
            Handlebars.js   - is an external library used to create templates which are a mix of HTML, text, and expressions.
            
            Invitations are a great example of a “real life” template.
            Inside a script, Handlebar expressions are wrapped with double braces, {{someVariable}}.
                Steps:
                    - Add the Handlebars library to your project.
                    - Create a Handlebars script in your HTML file.
                    - In your JavaScript file, grab the HTML stored in the Handlebars script.
                    - Use Handlebars.compile() to return a templating function.
                    - Pass in a context object to the templating function to get a compiled template.
                    - Render the compiled template onto the web page.
                
            Handlebars expressions.
                //index.html
                <head>
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.0.11/handlebars.js"></script>
                    <script id="ice-cream" type="text/x-handlebars-template">   // used to deliver a template to the browser.
                        <h2>Why {{flavor}} is the best</h2>
                        <p>It is without a doubt that {{flavor}} is the best ice cream flavor in the world.</p>
                    </script>
                </head>
                <body>
                    <div id="scream"></div>
                    <script src="main.js" type="text/javascript"></script>
                </body>

                // main.js
                const source = document.getElementById('ice-cream').innerHTML;
                const template = Handlebars.compile(source);
                const context = {
                    flavor: 'vanilla'
                };
                const compiledHtml = template(context);
                const iceCreamText = document.getElementById('scream');
                iceCreamText.innerHTML = compiledHtml;

            Handlebars "If" block helper & Handlebars "Else" section
                {{#if argument}}        // opening {{#if}} expression
                    // Code to include if the provided argument is truthy 
                {{else}}
                    // Code to include if the provided argument is falsy 
                {{/if}}                 // closing {{/if}} expression

            Handlebars "Each" and "This"        // allows you to iterate through an array
                {{#each someArray}}
                    <p>{{this}} is the current element!</p>     // {{this}} acts as a placeholder for the element in the iteration.
                {{/each}}
                
                This {{each}} block would be paired with an array like:
                    const context = {
                        someArray: ['First', 'Second', 'Third'] 
                    }
                    or  (but then {{this}} should be {{this.shape}})
                    const context = {
                        someArray: [
                            {shape: 'Triangle'},
                            {shape: 'Circle'},
                            {shape: 'Square'}
                        ] 
                    }


************************************************************************************************
************************************************************************************************
************************************************************************************************
7. Intermediate JavaScript
    CLASSES
        // See halley object 
        let halley = {
            _name: 'Halley',
            _behavior: 0,

            get name() {
                return this._name;
            },

            get behavior() {
                return this._behavior;
            },

            incrementBehavior() {
                this._behavior++;
            }
        }
        
        // See Class
        class Dog {
            constructor(name) {
                this._name = name;
                this._behavior = 0;
            }
            
            get name() {
                return this._name;
            }
            get behavior() {
                return this._behavior;
            }   
            
            incrementBehavior() {
                this._behavior ++;
            }
        }
        const halley = new Dog('Halley');   // class instantiation
        console.log(halley.name); 
        console.log(halley.behavior); 
        halley.incrementBehavior();         // method call
        console.log(halley.behavior); 

        JavaScript calls the constructor() method every time it creates a new instance of a class.
        In the context of a class, this refers to an instance of that class.
        Class method and getter syntax is the same as it is for objects except you can not include commas between methods.
        Notice, we also prepended our property names with underscores (_name and _behavior), which indicate these properties should not be accessed directly. 

        Inheritance
            When multiple classes share properties or methods, they become candidates for inheritance.
            With inheritance, you can create a parent class (also known as a superclass) with properties and methods that multiple child classes (also known as subclasses) share. The child classes inherit the properties and methods from their parent class.

            // Let's create a parent class named Animal for two child classes named Cat and Dog.
            class Animal {                  //  the Animal class contains the properties and methods that the Cat and Dog classes share (name, behavior, .incrementBehavior()).
                constructor(name) {
                    this._name = name;
                    this._behavior = 0;
                }
                
                get name() {
                    return this._name;
                }
                
                get behavior() {
                    return this._behavior;
                }   
                
                incrementBehavior() {
                    this._behavior++;
                }
            } 

            class Cat extends Animal {              // The 'extends' keyword makes the methods of the animal class available inside the cat class.
                constructor(name, usesLitter) {
                    super(name);                    // The super keyword calls the constructor of the parent class.
                    this._usesLitter = usesLitter;
                }
                get usesLitter() {
                    return this._usesLitter;
                }
            }
            class Dog extends Animal {
                constructor(name) {
                    super(name);
                }
            }
            // In a constructor(), you must always call the 'super' method before you can use the 'this' keyword — if you do not, JavaScript will throw a reference error.

            // create a new Cat instance
            const bryceCat = new Cat('Bryce', false); 
            console.log(bryceCat._name); // output: Bryce       // we abandoned best practices by calling our _name property directly. In the next exercise, we’ll address this by calling an inherited getter method for our name property.

        Static Methods
            Sometimes you will want a class to have methods that aren’t available in individual instances, but that you can call directly from the class.
            e.g. Date.now()     // The .now() method is static, so you can call it directly from the class, but not from an instance of the class.

            class Animal {
                constructor(name) {
                    this._name = name;
                    this._behavior = 0;
                }
                
                static generateName() {
                    const names = ['Angel', 'Spike', 'Buffy', 'Willow', 'Tara'];
                    const randomNumber = Math.floor(Math.random()*5);
                    return names[randomNumber];
                }
            } 
            console.log(Animal.generateName()); // returns a name
            const tyson = new Animal('Tyson');  // You cannot access the .generateName() method from instances of the Animal class or instances of its subclasses
            tyson.generateName(); // TypeError

    MODULES
        JavaScript modules are reusable pieces of code that can be exported from one program and imported for use in another program.
        Separate code with similar logic into files called modules.
        Syntax:
            - require()  /  module.exports 
                Every JavaScript file run in Node has a local module object with an exports property used to define what should be exported from the file.
                    let Menu = {};
                    Menu.specialty = "Roasted Beet Burger with Mint Sauce";
                    module.exports = Menu; 

                    or

                    module.exports = {
                        specialty: "Roasted Beet Burger with Mint Sauce",
                        getSpecialty: function() {
                            return this.specialty;
                        } 
                    }; 
    
                In Node.js, use the require() function to import modules.
                    const Menu = require('./menu.js');
                    function placeOrder() {
                      console.log('My order is: ' + Menu.specialty);
                    }
                    placeOrder();
            - ES6 import/export
                Two techniques: default export and named exports.
                Node.js doesn’t support export default by default, so module.exports is usually used for Node.js development and ES6 syntax is used for front-end development.
                    // Default Export
                    let Menu = {};
                    export default Menu;

                    import Menu from './menu';
                    
                    // Named Exports (allow us to export data through the use of variables.)
                    let specialty = '';
                    function isVegetarian() {}; 
                    function isLowSodium() {}; 
                    export { specialty, isVegetarian };

                    or 

                    export let specialty = '';
                    export function isVegetarian() {}; 
                    function isLowSodium() {}; 

                    or 

                    // Export as: Named exports also conveniently offer a way to change the name of variables when we export or import them. We can do this with the as keyword.
                    export { specialty as chefsSpecial, isVegetarian as isVeg, isLowSodium };
                    import { chefsSpecial, isVeg } from './menu';
                    import * as Carte from './menu';    // Another way of using aliases is to import the entire module as an alias:

                    //Named Imports
                    import { specialty, isVegetarian } from './menu';
                    console.log(specialty);

                Combining Export Statements: We can also use named exports and default exports together.
                    let specialty = '';
                    function isVegetarian() {}; 
                    function isLowSodium() {}; 
                    function isGlutenFree() {};
                    export { specialty as chefsSpecial, isVegetarian as isVeg };
                    export default isGlutenFree;
                Combining Import Statements
                    import { specialty, isVegetarian, isLowSodium } from './menu';
                    import GlutenFree from './menu';

    ERRORS AND ERROR Handling
        There are entire engineering roles built around finding and fixing errors: 
            A site reliability engineer finds and report errors in web platforms. 
            A test engineer builds automated tests to discover errors in software and make sure that it meets a companies standards.
        A piece of software, called a compiler, is trying to translate your code so that your computer can understand and run it. However, the compiler is coming across a piece of code that it can’t interpret. As a result, it throws an error back to you to let you know that it has to stop and why.
        This information is logged as an 'error stack trace' — a printed message containing information about where the error occurred, what type of error was thrown, and a description of the error.
        to debug an error, ask yourself:
            1-In what line did the error occur?     // e.g. 1
            2-What type of error was thrown?        // e.g. ReferenceError
            3-What is the error message?            // e.g. myVariable is not defined
        JavaScript Error Types:
            - SyntaxError       // when a typo creates invalid code
            - ReferenceError    // will be thrown if you try to use a variable that does not exist.
            - TypeError         // if you attempt to perform an operation on a value of the wrong type. 
            - other four types: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
        
        Locating Silent Bugs (debugging)
            Is your code broken but not throwing errors? Walk through your code using console.log() statements. When unexpected results occur, isolate the bug and try to fix it.
        Steps on debugging: try to fix -> google/stackoverflow -> check documentation

        Runtime Errors
            When we execute code and a line of code throws an error, that error is referred to as a runtime error. 
            We can use the Error function to make our own error object with a message that is unique to our program!
                console.log(Error('Your password is too weak.'));
                console.log(new Error('Your password is too weak.'));
            Creating an error is not the same as throwing an error. A thrown error will cause the program to stop running.
            To throw an error in JavaScript, we use the throw keyword:
                throw Error('Something wrong happened');    // Error: Something wrong happened
                console.log('This will never run');
            Up to this point, thrown errors have caused our program to stop running.
            In JavaScript, we use try...catch statement to anticipate and handle errors. 
                try {
                    throw Error('This error will get caught');  
                } catch (e) {
                    console.log(e);     // Prints: This error will get caught
                }
                console.log('The thrown error that was caught in the try...catch statement!');  // Prints: 'The thrown error that was caught in the try...catch statement!'
            We can also use a try...catch statement to handle built-in errors that are thrown by the JavaScript engine.
                const someVar = 'Cannot be reassigned';
                try {
                    someVar = 'Still going to try';
                } catch(e) {
                    console.log(e);     // Prints: TypeError: Assignment to constant variable.
                }

    PROMISES
        Promise object, introduced with ES6. 
         A Promise object can be in one of three states:
            - Pending: The initial state— the operation has not completed yet.
            - Fulfilled: The operation has completed successfully and the promise now has a resolved value. For example, a request’s promise might resolve with a JSON object as its value.
            - Rejected: The operation has failed and the promise has a reason for the failure. 
        To create a new Promise object(use 'new' keyword, 'Promise' constructor method):
            const executorFunction = (resolve, reject) => { };
            const myFirstPromise = new Promise(executorFunction);
                - resolve is a function with one argument. Under the hood, if invoked, resolve() will change the promise’s status from pending to fulfilled, and the promise’s resolved value will be set to the argument passed into resolve().
                - reject is a function that takes a reason or error as an argument. Under the hood, if invoked, reject() will change the promise’s status from pending to rejected, and the promise’s rejection reason will be set to the argument passed into reject().
            
            const executorFunction = (resolve, reject) => {
                if (someCondition) {
                    resolve('I resolved!');
                } else {
                    reject('I rejected!'); 
                }
            }
            const myFirstPromise = new Promise(executorFunction);

        Knowing how to construct a promise is useful, but most of the time, knowing how to consume, or use, promises will be key. 
        Rather than constructing promises, you’ll be handling Promise objects returned to you as the result of an asynchronous operation.

        To construct asynchronous promises using setTimeout():
            const returnPromiseFunction = () => {
                return new Promise((resolve, reject) => {
                    setTimeout(( ) => {resolve('I resolved!')}, 1000);
                });
            };
            const prom = returnPromiseFunction();   // we invoked returnPromiseFunction() which returned a promise. prom will initially have a status of pending.

        Promise objects come with an aptly named .then() method. 
        .then() is a higher-order function— it takes two callback functions as arguments. We refer to these callbacks as handlers. When the promise settles, the appropriate handler will be invoked with that settled value.
            - The first handler, sometimes called onFulfilled, is a success handler, and it should contain the logic for the promise resolving.
            - The second handler, sometimes called onRejected, is a failure handler, and it should contain the logic for the promise rejecting.
        We can invoke .then() with one, both, or neither handler! One important feature of .then() is that it always returns a promise. 
            const prom = new Promise((resolve, reject) => {
                resolve('Yay!');
            });
            const handleSuccess = (resolvedValue) => {
                console.log(resolvedValue);
            };
            prom.then(handleSuccess); // Prints: 'Yay!'

            // Another example:
            let prom = new Promise((resolve, reject) => {
                let num = Math.random();
                if (num < .5 ){
                    resolve('Yay!');
                } else {
                    reject('Ohhh noooo!');
                }
            });
            const handleSuccess = (resolvedValue) => {
                console.log(resolvedValue);
            };
            const handleFailure = (rejectionReason) => {
                console.log(rejectionReason);
            };
            prom.then(handleSuccess, handleFailure);

            // Another example

            //app.js
            const {checkInventory} = require('./library.js');
            const order = [['sunglasses', 1], ['bags', 2]];
            const handleSuccess = (resolved) =>{
              console.log(resolved)
            }
            const handleFailure = (rejected) => {
              console.log(rejected)
            }
            checkInventory(order).then(handleSuccess, handleFailure);

            // library.js
            const inventory = {
                sunglasses: 1900,
                pants: 1088,
                bags: 1344
            };
            const checkInventory = (order) => {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        let inStock = order.every(item => inventory[item[0]] >= item[1]);
                        if (inStock) {
                            resolve(`Thank you. Your order was successful.`);
                        } else {
                            reject(`We're sorry. Your order could not be completed because some items are sold out.`);
                        }
                    }, 1000);
                })
            };
            module.exports = { checkInventory };

        One way to write cleaner code is to follow a principle called separation of concerns. Separation of concerns means organizing code into distinct sections each handling a specific task. 
        Instead of passing both handlers into one .then(), we can chain a second .then() with a failure handler to a first .then() with a success handler and both cases will be handled.
        To create even more readable code, we can use a different promise function: .catch().
        The .catch() function takes only one argument, onRejected. 
            prom
                .then((resolvedValue) => {
                    console.log(resolvedValue);
                })
                .catch((rejectionReason) => {
                    console.log(rejectionReason);
                });
        
        Chaining Multiple Promises:
        This process of chaining promises together is called composition. 
            firstPromiseFunction()
            .then((firstResolveVal) => {
              return secondPromiseFunction(firstResolveVal);
            })
            .then((secondResolveVal) => {
              console.log(secondResolveVal);
            });
        Promise composition allows for much more readable code than the nested callback syntax that preceded it.
        Common Mistakes(doesn’t follow best practices):    
            Mistake 1: Nesting promises instead of chaining them.
            Mistake 2: Forgetting to return a promise.      // won’t throw an error

        Promise.all()
        To maximize efficiency we should use 'concurrency', multiple asynchronous operations happening together. 
        With promises, we can do this with the function Promise.all().
        Promise.all() accepts an array of promises as its argument and returns a single promise.
            let myPromises = Promise.all([returnsPromOne(), returnsPromTwo(), returnsPromThree()]);
            myPromises
              .then((arrayOfValues) => {
                console.log(arrayOfValues);
              })
              .catch((rejectionReason) => {
                console.log(rejectionReason);
              });


    ASYNC-AWAIT
        callback    - Originally, JavaScript used callback functions to handle asynchronous actions. The problem with callbacks is that they encourage complexly nested code which quickly becomes difficult to read, debug, and scale.
        promises    - With ES6, JavaScript integrated native promises which allow us to write significantly more readable code.
        async       - ES8 provides a new syntax for handling our asynchronous action, async...await. The async...await syntax is syntactic sugar— it doesn’t introduce new functionality into the language, but rather introduces a new syntax for using promises and generators. 

        // async keyword
            async function myFunc() {
              // Function body here
            };
            myFunc();
        
        // async function expressions
            const myFunc = async () => {
              // Function body here
            };
            myFunc();
        
        async functions always return a promise. This means we can use traditional promise syntax, like .then() and .catch with our async functions.
        The await keyword can only be used inside an async function.
        With async...await, we use try...catch statements for error handling.

        Handling Independent Promises
            async function waiting() {
                const firstValue = await firstAsyncThing();
                const secondValue = await secondAsyncThing();
                console.log(firstValue, secondValue);
            }

            async function concurrent() {
                const firstPromise = firstAsyncThing();
                const secondPromise = secondAsyncThing();
                console.log(await firstPromise, await secondPromise);
            }
        Await Promise.all()

    REQUESTS
        Terms: HTTP, TCP, URL, DNS, IP, HTTPS.
        HTTP stands for Hypertext Transfer Protocol and is used to structure requests and responses over the internet. HTTP requires data to be transferred from one point to another over the network.
        The transfer of resources happens using TCP (Transmission Control Protocol). In viewing this webpage, TCP manages the channels between your browser and the server (in this case, codecademy.com).

        HTTP & TCP: How it Works
            When you type an address such as www.codecademy.com into your browser, you are commanding it to open a TCP channel to the server that responds to that URL (or Uniform Resource Locator, which you can read more about on Wikipedia). A URL is like your home address or phone number because it describes how to reach you.
            In this situation, your computer, which is making the request, is called the client. The URL you are requesting is the address that belongs to the server.
            Once the TCP connection is established, the client sends a HTTP GET request to the server to retrieve the webpage it should display. After the server has sent the response, it closes the TCP connection. If you open the website in your browser again, or if your browser automatically requests something from the server, a new connection is opened which follows the same process described above. GET requests are one kind of HTTP method a client can call. 
            After you type the URL into your browser, your browser will extract the http part and recognize that it is the name of the network protocol to use. Then, it takes the domain name from the URL, in this case “codecademy.com”, and asks the internet Domain Name Server to return an Internet Protocol (IP) address. The client then opens a connection to the server at that address, using the http protocol as specified. It will initiate a GET request to the server which contains the IP address of the host and optionally a data payload.
            The GET request contains the following text:
                GET / HTTP/1.1
                Host: www.codecademy.com
            If the server is able to locate the path requested, the server might respond with the header:
                HTTP/1.1 200 OK                 // This line is confirmation that the server understands the protocol that the client wants to communicate with (HTTP/1.1), and an HTTP status code signifying that the resource was found on the server.
                Content-Type: text/html         // This line shows the type of content that it will be sending to the client.
            If the server is not able to locate the path requested by the client, it will respond with the header:
                HTTP/1.1 404 NOT FOUND          // This might happen if the content was moved or if you typed in the URL path incorrectly or if the page was removed. 
        HTTPS
            Since your HTTP request can be read by anyone at certain network junctures, it might not be a good idea to deliver information such as your credit card or password using this protocol. Fortunately, many servers support HTTPS, short for HTTP Secure, which allows you to encrypt data that you send and receive.
            It is up to the businesses maintaining the servers to set it up. In order to support HTTPS, the business must apply for a certificate from a Certificate Authority.
            HTTP request methods: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
            
        Requests
            In this lesson, we will explain how to make GET and POST requests by using JavaScript’s XHR object. 
            We’ll use the Datamuse API for GET requests and the Rebrandly URL Shortener API for POST requests.
            JSON, JavaScript Object Notation, will be the format in which our data is sent to us. 
    
        XHR GET Requests
            Asynchronous JavaScript and XML (AJAX), enables requests to be made after the initial page load. 
            Initially, AJAX was used only for XML formatted data, now it can be used to make requests that have many different formats.
            XMLHttpRequest (XHR) API, named for XML, can be used to make many kinds of requests and supports other forms of data.
            XHR GET diagram: https://s3.amazonaws.com/codecademy-content/courses/intermediate-javascript-requests/diagrams/XHR+GET+diagram.svg

            Boilerplate code for an AJAX GET request using an XMLHttpRequest object:
                const xhr = new XMLHttpRequest();
                const url = 'https://api-to-call.com/endpoint';
                xhr.responseType = 'json';
                xhr.onreadystatechange = () =>{
                  if (xhr.readyState === XMLHttpRequest.DONE) {
                    return xhr.response
                  }
                }
                xhr.open('GET', url);   // creates a new request
                xhr.send();

            Datamuse API Documentation: https://www.datamuse.com/api/

            Now incorporate that boilerplate code to make a GET request to the Datamuse API to search for words that rhyme:

        XHR POST Requests
            The major difference between a GET request and POST request is that a POST request requires additional information to be sent through the request. This additional information is sent in the body of the post request.
            Rebrandly URL Shortener API https://developers.rebrandly.com/docs -> register for a free Rebrandly account -> click on account icon (in the top right hand corner) -> Account settings -> Select the tab “API keys” -> Click on the button “Generate new API key”.
            XHR POST diagram: https://s3.amazonaws.com/codecademy-content/courses/intermediate-javascript-requests/diagrams/XHR+POST+diagram.svg
                const xhr = new XMLHttpRequest();
                const url = 'https://api-to-call.com/endpoint';
                const data = JSON.stringify({id: '200'});
                xhr.responseType = 'json';
                xhr.onreadystatechange = () => {
                    if(xhr.readyState === XMLHttpRequest.DONE){
                        return xhr.response()
                    }
                }
                xhr.open('POST', url);
                xhr.send(data);
        
        -----   AJAX requests using fetch(), async, and await
        Requests with ES6
            In this lesson, we will explain how to use fetch(), which uses promises to handle requests. Then, we will simplify requests using async and await.

        GET requests using fetch()
            fetch() GET diagram:  https://s3.amazonaws.com/codecademy-content/courses/intermediate-javascript-requests/diagrams/fetch+GET+diagram.svg
            The fetch() function:
                - Creates a request object that contains relevant information that an API needs.
                - Sends that request object to the API endpoint provided.
                - Returns a promise that ultimately resolves to a response object, which contains the status of the promise with information the API sent back.
            
                fetch('https://api-to-call.com/endpoint').then((response)=>{
                    if(response.ok){
                        return response.json();
                    }
                    throw new Error('Request failed!')
                }, (networkError)=>{
                    console.log(networkError.message)
                }).then((jsonResponse)=>{
                    return jsonResponse
                })

        fetch() POST Requests
            Notice that the initial call takes two arguments: an endpoint and an object that contains information needed for the POST request. The rest of the request is identical to the GET request.
            fetch() POST diagram: https://s3.amazonaws.com/codecademy-content/courses/intermediate-javascript-requests/diagrams/fetch+POST+diagram.svg
        
        async GET Requests
            async/await GET diagram: https://s3.amazonaws.com/codecademy-content/courses/intermediate-javascript-requests/diagrams/async+await+GET+diagram.svg

            const getData = async ()=>{
                try {
                    const response = await fetch('https://api-to-call.com/endpoint');
                    if(response.ok){
                        const jsonResponse = await response.json();
                        return jsonResponse;
                    }
                    throw new Error('Request failed!')
                } catch(error) {
                    console.log(error);   // Generally, developers create a more sophisticated way of handling the error, like redirecting their users to another page, but logging is fine for us at the moment.
                }
            }

        async POST Requests
            We still have the same structure of using try and catch as before. But, in the fetch() call, we now have to include an additional argument that contains more information like method and body.
            async/await POST diagram: https://s3.amazonaws.com/codecademy-content/courses/intermediate-javascript-requests/diagrams/async+await+POST+diagram.svg

                const getData = async ()=> {
                    try{
                        const response = await fetch('https://api-to-call.com/endpoint', {
                            method: 'POST',
                            body: JSON.stringify({id: 200})
                        });
                        if(response.ok){
                            const jsonResponse = await response.json();
                            return jsonResponse;
                        }
                        throw new Error('Request failed!');
                    } catch(error) {
                        console.log(error)
                    }
                }
            If you’re going to make POST requests, make sure you assign apiKey your Rebrandly API key.

        Foursquare API: https://developer.foursquare.com/   -> register for developer accounts for both of the APIs -> create a new app and fill out the form (you can put any link in the “App or Company URL” field). The Foursquare API will then give you a client ID and a client secret. You’ll need to save both of those in main.js.
        OpenWeather API: https://openweathermap.org/current -> register for developer accounts for both of the APIs -> Registration process: How to start: https://openweathermap.org/guide/#how -> When prompted, use your first name, and 'other' for the OpenWeather questions for their data collection. OpenWeather will give you an API Key, which you’ll also need to save in main.js.



************************************************************************************************
************************************************************************************************
************************************************************************************************
8. Learn the Command Line
    Terms: command line, filesystem, directories, wildcards, redirection
    NAVIGATION
        > ls 
        In the terminal, first you see $. This is called a shell prompt. It appears when the terminal is ready to accept a command.
        A filesystem organizes a computer’s files and directories into a tree structure:
            - The first directory in the filesystem is the root directory. It is the parent of all other directories and files in the filesystem.
            - Each parent directory can contain more child directories and files. 
            - Each directory can contain more files and child directories. 
        > pwd   // stands for “print working directory”, It outputs the name of the directory you are currently in, called the working directory.
        > cd 2015 // stands for “change directory”.
        > cd ..
        > mkdir media   // stands for “make directory”
        > touch keyboard.txt    // creates a new file inside the working directory. 
        Command Line Interfaces (CLIs) come in many forms. The CLI we’ll use is called Bash.
        Bash, or the Bourne-Again SHell, is a CLI that was created as a free software replacement for the Bourne Shell. A shell is a specific kind of CLI.
        Bash is the default shell for Linux and Mac. For these reasons, Bash is the most used and widely distributed shell. 
        To access Bash in OS X, you can use an application called Terminal.
        Windows has a different CLI, called Command Prompt. To use Bash on a Windows computer, we will download and install a program called Git Bash.
    MANIPULATION    // copy, move, and remove files and directories
        > ls -a     // The -a is called an option. 
            -a - lists all contents, including hidden files and directories
            -l - lists all contents of a directory in long format
                Columns:
                    Access rights. These are actions that are permitted on a file or directory.
                    Number of hard links. This number counts the number of child directories and files. This number includes the parent directory link (..) and current directory link (.).
                    The username of the file’s owner. Here the username is cc.
                    The name of the group that owns the file. Here the group name is eng.
                    The size of the file in bytes.
                    The date & time that the file was last modified.
                    The name of the file or directory.
            -t - order files and directories by the time they were last modified.
        > cp frida.txt lincoln.txt  // copy the contents of frida.txt into lincoln.txt.
        > cp biopic/ray.txt biopic/notorious.txt historical/    // To copy multiple files into a directory, use cp with a list of source files as the first arguments, and the destination directory as the last argument. 
        > cp * satire/ 
        > cp m*.txt scifi/  // copy of all text files starting with “m”
        In addition to using filenames as arguments, we can use special characters like * to select groups of files. These special characters are called wildcards. The * selects all files in the working directory.
        > mv superman.txt superhero/ 
        > mv batman.txt spiderman.txt   // to rename a file, e.g. batman.txt has been renamed as spiderman.txt.
        > rm waterboy.txt 
        > rm -r slapstick   // The -r stands for “recursive,” and it’s used to delete a directory and all of its child directories.
    REDIRECTION
        The common redirection commands are:
            > redirects standard output of a command to a file, overwriting previous content.
            >> redirects standard output of a command to a file, appending new content to old content.
            < redirects standard input to a command.
            | redirects standard output of a command to another command.

        Through redirection you can direct the input and output of a command to and from other files and programs, and chain commands together in a pipeline.
        > echo "Hello"  // The echo command accepts the string “Hello” as standard input, and echoes the string “Hello” back to the terminal as standard output.
            standard input,     abbreviated as stdin, is information inputted into the terminal through the keyboard or input device.
            standard output,    abbreviated as stdout, is the information outputted after a process is run.
            standard error,     abbreviated as stderr, is an error message outputted by a failed process.
        > echo "Hello" > hello.txt  // redirect, The > command redirects the standard output to a file. "Hello" is entered as the standard input.
        > cat hello.txt 
        > cat oceans.txt > continents.txt // > takes the standard output of the command on the left, and redirects it to the file on the right.
            When you view the output data by typing cat on continents.txt, you will see only the contents of oceans.txt.
        > cat glaciers.txt >> rivers.txt    // to see both rivers and glaciers as output.
            >> takes the standard output of the command on the left and appends (adds) it to the file on the right.
        > cat < lakes.txt // < takes the standard input from the file on the right and inputs it into the program on the left. Here, lakes.txt is the standard input for the cat command. The standard output appears in the terminal.
        > cat volcanoes.txt | wc 
            | is a “pipe”. The | takes the standard output of the command on the left, and pipes it as standard input to the command on the right. You can think of this as “command to command” redirection.
            wc command outputs the number of lines, words, and characters in volcanoes.txt
        > sort lakes.txt    // takes the standard input and orders it alphabetically for the standard output. 
        > cat lakes.txt | sort > sorted-lakes.txt
        > uniq deserts.txt  //  stands for “unique” and filters out adjacent, duplicate lines in a file. 
        > sort deserts.txt | uniq 
        > grep Mount mountains.txt  // grep stands for “global regular expression print”. It searches files for lines that match a pattern and returns the results. It is also case sensitive. Here, grep searches for “Mount” in mountains.txt.
        > grep -i Mount mountains.txt   // grep -i enables the command to be case insensitive.
        grep can also be used to search within a directory. 
        > grep -R Arctic /home/ccuser/workspace/geography   // -R stands for “recursive”. 
        > grep -Rl Arctic /home/ccuser/workspace/geography  // l stands for “files with matches”
        > sed 's/snow/rain/' forests.txt    // sed stands for “stream editor”. It accepts standard input and modifies it based on an expression, before displaying it as output data. It is similar to “find and replace”.
            Let’s look at the expression 's/snow/rain/':
                s: stands for “substitution”. it is always used when using sed for substitution.
                snow: the search string, the text to find.
                rain: the replacement string, the text to add in place.
                In this case, sed searches forests.txt for the word “snow” and replaces it with “rain.”
                Importantly, the above command will only replace the first instance of “snow” on a line.
        > sed 's/snow/rain/g' forests.txt 
            The above command uses the g expression, meaning “global”. Here sed searches forests.txt for the word “snow” and replaces it with “rain”, globally. All instances of “snow” on a line will be turned to “rain”.
    ENVIRONMENT
        nano is a command line text editor. 
        > nano hello.txt    // to open the nano text editor.
            type Ctrl + O to save the file.     The ^ stands for the Ctrl key.
            Press Enter, when prompted about the filename to write.
            Ctrl + X to exit nano.
        > clear         // to clear the terminal window. 
        > source ~/.bash_profile    // to activate the changes in ~/.bash_profile for the current session. Instead of closing the terminal and needing to start a new session, source makes the changes available right away in the session we are in.
            In .bash_profile add: 
                echo "Welcome, Jane Doe" 
                alias pd="pwd"          // The alias command allows you to create keyboard shortcuts, or aliases, for commonly used commands.
                export USER="Jane Doe"  // (environment variables)to return the value of the variable type: $echo $USER 
                export PS1=">> "        // (environment variables)to change prompt from defaul $ to >>. PS1 is a variable that defines the makeup and style of the command prompt.
            ~/.bash_profile is the name of file used to store environment settings
        > echo $HOME
        > echo $PATH  // Each directory contains scripts for the command line to execute. 
            home/ccuser/.gem/ruby/2.0.0/bin
            /usr/local/sbin
            /usr/local/bin
            /usr/bin
            /usr/sbin
            /sbin
            /bin
        > /bin/pwd    // This is the script that is executed when you type the pwd command.
        > /bin/ls     // This is the script that is executed when you type the ls command.
        > env           // returns a list of the environment variables for the current user.
        > less file.txt     // similar to cat, but is better adapted to handling larger files. Type q to quit.
    BASH SCRIPTING
        Bash (or shell) scripting is a great way to automate repetitive tasks.
        Bash scripts execute within a Bash shell interpreter terminal. Any command you can run in your terminal can be run in a Bash script.
        The beginning of your script file should start with #!/bin/bash on its own line. // This tells the computer which type of interpreter to use for the script. 
        When saving the script file, it is good practice to place commonly used scripts in the ~/bin/ directory.
        The script files also need to have the “execute” permission to allow them to be run. 
        To add this permission to a file with filename: script.sh use:
            chmod +x script.sh
        Your terminal runs a file every time it is opened to load its configuration. 
            On Linux style shells, this is ~/.bashrc and 
            on OSX, this is ~/.bash_profile. 
        To ensure that scripts in ~/bin/ are available, you must add this directory to your PATH within your configuration file:
            PATH=~/bin:$PATH
        Now any scripts in the ~/bin directory can be run from anywhere by typing the filename.
        Use ./script.sh to run the script.
        Variables: 
            greeting="Hello"    // variables are declared by setting the variable name equal to another value.
            echo $greeting      // To access the value of a variable, we use the variable name prepended with a dollar sign ($).
        Conditionals:
            Use if to start the conditional, followed by the condition in square brackets ([ ]).
            'then' begins the code that will run if the condition is met. 
            'else' begins the code that will run if the condition is not met. 
            The conditional is closed with a backwards if, fi.
            Operators:
                Equal: -eq
                Not equal: -ne
                Less than or equal: -le
                Less than: -lt
                Greater than or equal: -ge
                Greater than: -gt
                Is null: -z
                Equal: ==
                Not equal: !=
            e.g.
                if [ $index -lt 5 ]
                then
                    echo $index
                else
                    echo 5
                fi
        Loops:  // for, while and until.
            for word in $paragraph
            do
                echo $word
            done

            while [ $index -lt 5 ]
            do
                echo $index
                index=$((index + 1))
            done

            until [ $index -eq 5 ]
            do
                echo $index
                index=$((index + 1))
            done
        Inputs
            To make bash scripts more useful, we need to be able to access data external to the bash script file itself. 
            1-The first way to do this is by prompting the user for input. For this, we use the 'read' syntax. To ask the user for input and save it to the number variable:
                echo "Guess a number"
                read number
                echo "You guessed $number"
            2-Another way to access external data is to have the user add input arguments when they run your script. These arguments are entered after the script name and are separated by spaces.
                e.g. saycolors red green blue
            3-Lastly, we can access external files to our script. You can assign a set of files to a variable name using standard bash pattern matching using regular expressions. 
                files=/some/directory/*
                for file in $files
                do
                    echo $file
                done
        Aliases
            e.g.    alias saycolors='./saycolors.sh'
                    alias saycolors='./saycolors.sh "green"'    // add standard input arguments to your alias
************************************************************************************************
************************************************************************************************
************************************************************************************************
9. Learn Git
    BASIC GIT WORKFLOW
        > git init
        Three parts of Git ptoject:
            - git init->    A Working Directory:  where you’ll be doing all the work: creating, editing, deleting and organizing files
            - git add->     A Staging Area:       where you’ll list changes you make to the working directory
            - git commit->  A Repository:         where Git permanently stores those changes as different versions of the project
        > git status
        > git add filename
        > git diff filename     // to check the differences between the working directory and the staging area
        > git commit -m "Complete first line of dialogue"
        Standard Conventions for Commit Messages:
            - Must be in quotation marks
            - Written in the present tense
            - Should be brief (50 characters or less) when using -m
        > git log               // to view commits that are stored chronologically in the repository
        In the output, notice:
            A 40-character code, called a SHA, that uniquely identifies the commit. This appears in orange text.
            The commit author (you!)
            The date and time of the commit
            The commit message
    HOW TO BACKTRACK
        In many cases, the most recently made commit is the HEAD commit.
        > git show HEAD         // To see the HEAD commit
        // вернуть предыдущую версию файла после git commit:
        > git checkout HEAD filename    // (re-open the file to see the result) To restore a file in the working directory to look as it did in your last commit
        > git checkout -- filename      // the same exact thing that 'git checkout HEAD filename' does.
        // если сделала git add и нужно отменить:
        > git reset HEAD filename       // unstage file from the staging area. In output, M is short for “modification”
        > git reset commit_SHA  // e.g. if the SHA of the previous commit is 5d692065cf51a2f50ea8e7b19b5a7ae512f633ba, use: git reset 5d69206
    GIT BRANCHING
        Up to this point, you’ve worked in a single Git branch called master.    
        Git allows us to create branches to experiment with versions of a project.
        > git branch        // to answer the question: “which branch am I on?”
            In the output, the * (asterisk) is showing you what branch you’re on.
        > git branch new_branch     // To create a new branch
        > git checkout branch_name  // to switch to the new branch
        Every commit 'master' has, 'new_branch' also has.
        > git merge branch_name     // (but be in 'master'(receiver) branch before running this command)if you wanted include all the changes made to the 'new_branch'(giver branch) on the 'master' branch(receiver branch)
        The merge was successful because 'master' had not changed since we made a commit on 'new_branch'.
        What would happen if you made a commit on master before you merged the two branches? -> merge conflict.
        To fix the merge conflict:
            Git uses markings to indicate the HEAD (master) version of the file and the fencing version of the file, like this:
                <<<<<<< HEAD
                master version of line
                =======
                fencing version of line
                >>>>>>> fencing
            Git asks us which version of the file to keep: the version on master or the version on fencing. You decide you want the fencing version.
            From the code editor: Delete the content of the line as it appears in the master branch
            Delete all of Git’s special markings including the words HEAD and fencing. If any of Git’s markings remain, for example, >>>>>>> and =======, the conflict remains.
            Then 'git add ', git commit -m 'Resolve merge conflict'
        > git branch -d branch_name     // delete branch
            In Git, branches are usually a means to an end. You create them to work on a new project feature, 
            but the end goal is to merge that feature into the master branch. After the branch has been 
            integrated into master, it has served its purpose and can be deleted.
    GIT TEAMWORK
        A remote is a shared Git repository that allows multiple collaborators to work on the same Git project from different locations. 
        Collaborators work on the project independently, and merge changes together when they are ready to do so.
        > git clone remote_location clone_name  // In order to get your own replica of remote repository
            remote_location     - tells Git where to go to find the remote. This could be a web address, or a filepath, such as: /Users/teachers/Documents/some-remote
            clone_name          - is the name you give to the directory in which Git will clone the repository.
        > git remote -v     // to see a list of a Git project’s remotes 
            Notice the output:
                origin    /home/ccuser/workspace/curriculum/science-quizzes (fetch)
                origin    /home/ccuser/workspace/curriculum/science-quizzes (push)
        > git fetch     // to see if changes have been made to the remote and bring the changes down to your local copy
            This command will not merge changes from the remote into your local repository. It brings those changes onto what’s called a remote branch.
        > git merge origin/master   // to integrate origin/master into your local master branch. 
            Git has performed a “fast-forward” merge, bringing your local master branch up to speed with most recent commit on the remote.
        
        Now that you’ve merged origin/master into your local master branch, you’re ready to contribute some work of your own.
        The workflow for Git collaborations typically follows this order:
            1- Fetch and merge changes from the remote
            2- Create a branch to work on a new project feature
            3- Develop the feature on your branch and commit your work
            4- Fetch and merge from the remote again (in case new commits were made while you were working)
            5- Push your branch up to the remote for review
            Steps 1 and 4 are a safeguard against merge conflicts.
        > git push origin your_branch_name  // will push your branch up to the remote, origin. 
            Someone can now review your new work and can merge it into the remote’s master branch.

************************************************************************************************
************************************************************************************************
************************************************************************************************

10. Building Front-end Applications with React
    -------------------- Browser Compatibility and Transpilation --------------------
    Update your web browser every few months -> browser compatibility issues, tools: 
        caniuse.com
        Babel   -   JS library to transpile ES6 to ES5.
            Two required Babel packages:
            > npm init  // to create a package.json file
            > npm install babel-cli -D
            > npm install babel-preset-env -D
                The -D flag instructs npm to add each package to a property called devDependencies in package.json. 
                Once the project’s dependencies are listed in devDependencies, other developers can run your 
                project without installing each package separately. Instead, they can simply run 'npm install' — 
                it instructs npm to look inside package.json and download all of the packages listed in devDependencies.
            > touch .babelrc    // to specify the initial JS version inside of a file named .babelrc.
                {
                    "presets": ["env"]
                }
            In package,json add script:
                "build": "babel src -d lib" // to transpile ES6+ code to ES5. 
                                            // src — Instructs Babel to transpile all JS code inside the 'src' directory.
                                            // -d — Instructs Babel to write the transpiled code to a directory.
                                            // lib — Babel writes the transpiled code to a directory called 'lib'.
            > npm run build

    Transpilation is the process of converting one programming language to another.

    ES6:
        - ES5: var -> ES6: let, const
        - In ES5, we used plus signs (+) to interpolate variables into strings. -> ES6 string interpolation
        Template literals: const carbonara = `You can make carbonara with ${pasta}.`;

    -------------------- JSX --------------------
    React: fast, modular, scalable, flexible, popular.

    const h1 = <h1>Hello world</h1>;    // The part that looks like HTML, <h1>Hello world</h1>, is called JSX.
    JSX is a syntax extension for JavaScript. If a JavaScript file contains JSX code, then that file will have to be compiled. 
    That means that before the file reaches a web browser, a JSX compiler will translate any JSX into regular JavaScript.
    -> Wrap the multi-line JSX expression in parentheses:
        const theExample = (                        // can be saved as variables, object, passed to f-ns etc.
            <a href="https://www.example.com">
                <h1>
                Click me!
                </h1>
            </a>
        )
    -> JSX expression must have exactly one outermost element. Simple solution: wrap the JSX expression in a <div></div>
    -> To render a JSX expression means to make it appear onscreen.
        ReactDOM.render(<h1>Hello world</h1>, document.getElementById('app'));
            ReactDOM is the name of a JavaScript library. 
    -> ReactDOM.render()‘s first argument should evaluate to a JSX expression, it doesn’t have to literally be a JSX expression.
        const toDoList = (
            <ol>
                <li>Learn React</li>
                <li>Become a Developer</li>
            </ol>
        );
        ReactDOM.render(toDoList, document.getElementById('app'));
    -> The Virtual DOM
        One special thing about ReactDOM.render() is that it only updates DOM elements that have changed.
        That means that if you render the exact same thing twice in a row, the second render will do nothing.
        React accomplishes this thanks to something called the virtual DOM. 
    -> Advanced JSX: class vs className
        - class -> className
        - Self-Closing Tags
            In HTML, it is optional to include a forward-slash immediately before the final angle-bracket: <br> or <br />
            In JSX, you have to include the slash: <br />
        - Curly Braces in JSX
            Any code in between the tags of a JSX element will be read as JSX, not as regular JS: <h1>{2+3}</h1> // 2+3
            Everything inside of the curly braces will be treated as regular JS: <h1>{2+3}</h1> //6
        - Variables in JSX
            const name = 'Gerdo';   // Declare a variable:
            const greeting = <p>Hello, {name}!</p>; // Access your variable from inside of a JSX expression
        - Variable Attributes in JSX
            const pics = {
                panda: "http://bit.ly/1Tqltv5",
                owl: "http://bit.ly/1XGtkM3",
                owlCat: "http://bit.ly/1Upbczi"
            }; 
            const panda = (
                <img src={pics.panda} 
                alt="Lazy Panda" />
            );
        - Event Listeners in JSX
            An event listener attribute’s name should be something like onClick or onMouseOver: the word on, plus the type of event that you’re listening for.
            List of valid events: https://reactjs.org/docs/events.html#supported-events
            An event listener attribute’s value should be a function.
            Note that in HTML, event listener names are written in all lowercase, such as onclick or onmouseover. In JSX, event listener names are written in camelCase, such as onClick or onMouseOver.
                function myFunc() {
                    alert('Make myFunc the pFunc... omg that was horrible i am so sorry');
                }
                <img onClick={myFunc} />
        - JSX Conditionals: 
            - If Statements     - works when the words if and else are not injected in between JSX tags.
                if (user.age >= drinkingAge) {
                    message = (
                        <h1>
                        Hey, check out this alcoholic beverage!
                        </h1>
                    );
                    } else {
                    message = (
                        <h1>
                        Hey, check out these earrings I got at Claire's!
                        </h1>
                    );
                }
            - The Ternary Operator
                const headline = (
                    <h1>
                        { age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }
                    </h1>
                );
            - &&
                const tasty = (
                    <ul>
                        <li>Applesauce</li>
                        { !baby && <li>Pizza</li> }
                        { age > 15 && <li>Brussels Sprouts</li> }
                        { age > 20 && <li>Oysters</li> }
                        { age > 25 && <li>Grappa</li> }
                    </ul>
                );
        - .map in JSX
            const strings = ['Home', 'Shop', 'About Me'];
            const listItems = strings.map(string => <li>{string}</li>);
            <ul>{listItems}</ul>
        - Keys
            A key is a JSX attribute. The attribute’s name is key. The attribute’s value should be something unique, similar to an id attribute.
            keys don’t do anything that you can see! React uses them internally to keep track of lists. If you don’t use keys when you’re supposed to, React might accidentally scramble your list-items into the wrong order.
            Not all lists need to have keys. If you aren’t sure then it never hurts to use them! 
            A list needs keys if either of the following are true:
                1.The list-items have memory from one render to the next. For instance, when a to-do list renders, each item must “remember” whether it was checked off. The items shouldn’t get amnesia when they render.
                2.A list’s order might be shuffled. For instance, a list of search results might be shuffled from one render to the next.

                const peopleLis = people.map((person, i) =>
                    <li key={'person_' + i}>{person}</li>
                );
        - React.createElement
            You can write React code without using JSX at all!
                The following JSX expression:
                    const h1 = <h1>Hello world</h1>;
                can be rewritten without JSX, like this:
                    const h1 = React.createElement(
                        "h1",
                        null,
                        "Hello, world"
                    );
            When a JSX element is compiled, the compiler transforms the JSX element into the method: React.createElement(). Every JSX element is secretly a call to React.createElement().
        
    -------------------- React Components --------------------
    React class component:
        import React from 'react';                          // creates js object, create a variable named React, get the React library. You’ve already seen one of the methods contained in the React library: React.createElement(). 
        import ReactDOM from 'react-dom';                   // creates another js object
        class MyComponentClass extends React.Component {    // Component class variable names must begin with capital letters!
            render() {                                      // A render method is a property whose name is render, and whose value is a function.
                return <h1>Hello world</h1>;                // A render method must contain a return statement. Usually, this return statement returns a JSX expression:
            }
        };
        ReactDOM.render(<MyComponentClass />, document.getElementById('app'));  // component instance. JSX elements can be either HTML-like, or component instances. ReactDOM.render() will tell <MyComponentClass /> to call its render method.

    Multi-line JSX expression should always be wrapped in parentheses.

    Variable Attribute in a Component
        import React from 'react';
        import ReactDOM from 'react-dom';
        const redPanda = {
            src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',
            alt: 'Red Panda',
            width:  '200px'
        };
        class RedPanda extends React.Component {
            render() {
                return (
                    <div>
                        <h1>Cute Red Panda</h1>
                        <img 
                        src={redPanda.src}
                        alt={redPanda.alt}
                        width={redPanda.width} />
                    </div>
                );
            }
        }
        ReactDOM.render(<RedPanda />, document.getElementById('app'));
    
    Put Logic in a Render Function
        class Random extends React.Component {
            render() {
                const n = Math.floor(Math.random() * 10 + 1);   // This should be in the render function!!! it should not be part of the class declaration itself, but should occur in a method like render().
                return <h1>The number is {n}!</h1>;
            }
        }
    
    Use a Conditional in a Render Function
        class TodaysPlan extends React.Component {
            render() {
                let task;
                if (!apocalypse) {
                    task = 'learn React.js'
                } else {
                    task = 'run around'
                }
                return <h1>Today I am going to {task}!</h1>;
            }
        }

    Use this in a Component
        class IceCreamGuy extends React.Component {
            get food() {
                return 'ice cream';
            }
            render() {
                return <h1>I like {this.food}.</h1>;    // this refers to an instance of IceCreamGuy. You don’t need parentheses (e.g. this.food()) because .food is a getter method.
            }
        }

    Use an Event Listener in a Component
        class MyClass extends React.Component {
            myFunc() {
                alert('Stop it.  Stop hovering.');
            }
            render() {
                return (
                <div onHover={this.myFunc}>     // Event handler is a fn that gets called in response to an event, e.g. myFunc().
                </div>
                );
            }
        }
    
    Project: Authorization Form
        // Contact.js
        import React from 'react';
        import ReactDOM from 'react-dom';

        class Contact extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    password: 'swordfish',
                    authorized: false
                };
                this.authorize = this.authorize.bind(this);
            }

            authorize(e) {
                const password = e.target.querySelector('input[type="password"]').value;
                const auth = password == this.state.password;
                this.setState({
                    authorized: auth
                });
            }

            render() {
                const login = (
                    <form action='#' onSubmit={this.authorize}>
                        <input type="password" placeholder="Password" />
                        <input type="submit"/>
                    </form>
                );
                const contactInfo = (
                    <ul>
                        <li>
                            client@example.com
                        </li>
                        <li>
                            555.555.5555
                        </li>
                    </ul>
                );
                return (
                    <div id="authorization">
                        <h1>{ this.state.authorized ? 'Contact' : 'Enter the Password' }</h1> 
                        {this.state.authorized ? contactInfo : login}
                    </div>
                );
            }
        }
        ReactDOM.render(<Contact />, document.getElementById('app'));


    -------------------- React Development Setup and Ravenous: part 1 --------------------
    CLI
        Bash is the default shell for Linux and Mac (more popular).
        Windows has a different CLI, called Command Prompt. To use Bash on a Windows computer, download and install a program called Git Bash. 

    Node
        > which node    //  print the filepath to Node, e.g. /Users/serhii/.nvm/versions/node/v13.13.0/bin/node
        > node -v       // e.g. v13.13.0

    Creating a React App
        > npm install -g create-react-app   // install the create-react-app node module
        > create-react-app <name-of-app>

        React app structure:
            .gitignore
            README.md
            node_modules
            package-lock.json   // This file contains the exact dependency tree installed in node_modules/. This provides a way for teams working on private apps to ensure that they have the same version of dependencies and sub-dependencies. It also contains a history of changes to package.json, so you can quickly look back at dependency changes.
            package.json    
            public              // This directory contains assets that will be served directly without additional processing by webpack. index.html provides the entry point for the web app. 
            src                 // This contains the JavaScript that will be processed by webpack and is the heart of the React app. Browsing this folder, you see the main App JavaScript component (App.js), its associated styles (App.css), and test suite (App.test.js). index.js and its styles (index.css) provide an entry into the App and also kicks off the registerServiceWorker.js. This service worker takes care of caching and updating files for the end-user. It allows for offline capability and faster page loads after the initial visit. 

            As your React app grows, it is common to add
                components/ directory to organize components and component-related files and  
                views directory to organize React views and view-related files.

        Starting the React app development server
            > npm start     // http://localhost:3000/

    React Developer Tools
        Install React Developer Tools   // Chrome extension to help with debugging React Apps: to inspect React components, view their properties, and interact with them while looking at the application in Google Chrome.
            Modify Components with Javascript: select the main <App> component in React Developer Tools. You’ll see that it appends == $r to the right side of the component name in the tree. Now, if you switch over to the console view, you can access this component using $r. By logging $r, you can see that this is indeed the component selected in the React tab. You can do things like access its state, update its state, and access its props:
                &r
                &r.setState({foo:"bar"})
                &r.state
                &r.props

    Project: build a website called “Ravenous”, a Yelp-like clone.
        In total, there will be four parts to this project:
            1.Creating Static Components
            2.Passing Information to Components
            3.Setting the State of Ravenous Components
            4.Interacting with the Yelp API
        See project on github for futher details.

    -------------------- Components Interacting --------------------
    Ways that components can interact:
    1. component can render another component
        Render methods can return 
            - an HTML-like JSX element
            - another kind of JSX: component instances.
        
        Ways to use export:
            - named exports:
                In one file, place the keyword export immediately before e.g. var, let, const, function, or class
                    export const faveManifestos = {....};
                In a different file, import the name of the var, let, const, function, or class from the first file
                    import { faveManifestos, alsoRan } from './Manifestos';
                When you use named exports, you always need to wrap your imported names in curly braces.
        
        By nesting components inside of other components, you can build infinitely complex architectures, even if each component is relatively simple. 
    
    2. component can pass information to another component.
    2.1. Information that gets passed from one component to another is known as “props.”
        You can pass information to a React component - By giving that component an attribute.
            <MyComponent foo="bar" />
            <Greeting myInfo={["top", "secret", "lol"]} />  //If you want to pass information that isn’t a string, then wrap that information in curly braces.

        Render a Component's props:
            class Greeting extends React.Component {
                render() {
                    return <h1>Hi there, {this.props.firstName}</h1>;   // this.props.name-of-information
                }
            }
            ReactDOM.render(<Greeting firstName='ok' />, document.getElementById('app'));
        
        The most common use of props is to pass information to a component, from a different component. 
            // Greeting.js
            import React from 'react';
            export class Greeting extends React.Component {
                render() {
                    return <h1>Hi there, {this.props.name}!</h1>;   // we don't use ReactDOM in this component
                }
            }

            // App.js
            import React from 'react';
            import ReactDOM from 'react-dom';
            import {Greeting} from './Greeting'
            class App extends React.Component {
                render() {
                    return (
                        <div>
                            <h1>Hullo and, "Welcome to The Newzz," "On Line!"</h1>
                            <Greeting name="ok"/>       // Pass props From Component To Component
                            <article>Latest newzz:  where is my phone?</article>
                        </div>
                    );
                }
            }
            ReactDOM.render(<App />, document.getElementById('app'));

        * Passing a prop by giving an attribute to a component instance
        * Accessing a passed-in prop via this.props.prop-name

        props vs prop
            props is the name of the object that stores passed-in information. this.props refers to that storage object. 
            At the same time, each piece of passed-in information is called a prop. 

        Render Different UI Based on props
            if (this.props.name == 'Wolfgang Amadeus Mozart') {....} else {....}    // we don't display name. 

        Put an Event Handler in a Component Class
            You can, and often will, pass functions as props. It is especially common to pass event handler functions.
                class Example extends React.Component {
                    handleEvent() {
                        alert(`I am an event handler.`);
                    }
                    render() {
                        return (
                            <h1 onClick={this.handleEvent}>Hello world</h1>
                        );
                    }
                }
        
        >> Pass an Event Handler as a prop
            class Talker extends React.Component {
                talk() {    // event handler
                    ....
                }
                render() {
                    return <Button talk={this.talk} />;     // passed a fn from <Talker /> to <Button />
                }
            }
        >> Receive an Event Handler as a prop
            export class Button extends React.Component {
                render() {
                    return (
                        <button onClick={this.props.talk}>  // attach talk to the <button></button> as an event handler.
                            Click me!
                        </button>
                    );
                }
            }   
        
        handleEvent, onEvent, and this.props.onEvent
            Here’s how the naming convention works: first, think about what type of event you are listening for. In our example, the event type was “click.”
                If you are listening for a “click” event, then you name your event handler handleClick. If you are listening for a “keyPress” event, then you name your event handler handleKeyPress.
                Your prop name should be the word on, plus your event type. If you are listening for a “click” event, then you name your prop onClick.
                    return <Child onHover={this.handleHover} />;

        this.props.children
            this.props.children will return everything in between a component’s opening and closing JSX tags.
                class BigButton extends React.Component {
                    render() {
                        console.log(this.props.children);
                        return <button>Yo I am big</button>;
                    }
                }

                // Example 1    - this.props.children would equal the text, “I am a child of BigButton.”
                <BigButton>
                    I am a child of BigButton.
                </BigButton>

                // Example 2    - this.props.children would equal a <LilButton /> component.
                <BigButton>
                    <LilButton />
                </BigButton>

                // Example 3    - this.props.children would equal undefined.
                <BigButton />
            
            If a component has more than one child between its JSX tags, then this.props.children will return those children in an array. However, if a component has only one child, then this.props.children will return the single child, not wrapped in an array.

        defaultProps
            e.g. <button>{this.props.text}</button>
            If nobody passes any text to Button, then Button‘s display will be blank. It would be better if Button could display a default message instead.
            Example.defaultProps = { text: 'yo' };
        
    2.2. React components will often need dynamic information (information that can change) in order to render. 
        A React component can access dynamic information in two ways: props and state.
        Unlike props, a component’s state is not passed in from the outside. A component decides its own state.
        To make a component have state, give the component a state property. This property should be declared inside of a constructor method.
            class Example extends React.Component {
                constructor(props) {
                    super(props);                       // React components always have to call super in their constructors to be set up properly.
                    this.state = { mood: 'decent' };    // This object represents the initial “state” of any component instance.
                }
                render() {
                    return <h1>I'm feeling {this.state.mood}!</h1>;     // Access a Component's state
                }
            }
            <Example />
        
        Update state with this.setState
            this.setState() takes two arguments: an object that will update the component’s state, and a callback. You basically never need the callback.
            this.setState() takes an object, and merges that object with the component’s current state. If there are properties in the current state that aren’t part of that object, then those properties remain how they were.
        Call this.setState from Another Function
            The most common way to call this.setState() is to call a custom function that wraps a this.setState() call.
            P.S. just know that in React, whenever you define an event handler that uses 'this', you need to add this.methodName = this.methodName.bind(this) to your constructor function.
            You can’t call this.setState() from inside of the render function! 
                class Example extends React.Component {
                    constructor(props) {
                        super(props);
                        this.state = { weather: 'sunny' };
                        this.makeSomeFog = this.makeSomeFog.bind(this); // This line is necessary because makeSomeFog()‘s body contains the word this.
                        // P.S. Due to the way that event handlers are bound in JavaScript, this.makeSomeFog() loses its 'this' (e.g. when it is used as event handler). Therefore, the expressions this.state.weather and this.setState in constructor won’t mean what they’re supposed to… unless you have already bound the correct this to this.makeSomeFog. That is why we must bind this.makeSomeFog to this.
                        // https://reactjs.org/docs/handling-events.html
                    }
                    makeSomeFog() {
                        const newWeather = this.state.weather == 'sunny' ? 'foggy' : 'sunny';
                        this.setState({ weather: newWeather });
                        // this.setState({weather: 'foggy'});
                    }
                    render() {
                        return (
                            <div>
                                <h1>The weather is {this.state.weather}!</h1>   //  changes a virtual DOM object’s weather title to the new this.state.weather, eventually causing a change in the screen.
                                <button onClick={this.makeSomeFog}>Click Me</button>
                            </div>
                        );
                    }
                }
        this.setState Automatically Calls render
            Why can you see the new background right away, if you haven’t re-rendered the component?
            !!! Here’s why: Any time that you call this.setState(), this.setState() AUTOMATICALLY calls .render() as soon as the state has changed.
            Think of this.setState() as actually being two things: this.setState(), immediately followed by .render().
            That is why you can’t call this.setState() from inside of the .render() method! this.setState() automatically calls .render(). If .render() calls this.setState(), then an infinite loop is created.

    -------------------- Ravenous: Part 2 --------------------
    -------------------- Stateless Components From Stateful Components --------------------
    Our programming pattern uses two React components: 
        - a stateful component, describes any component that has a state property;
        - a stateless component, describes any component that does not.
    In our pattern, a stateful component passes its state down to a stateless component.
        // Parent.js    - stateful component class
            import React from 'react';
            import ReactDOM from 'react-dom';
            import {Child} from './Child';
            class Parent extends React.Component {
                constructor(props){
                    super(props);
                    this.state = {name: "Frarthur"};
                }
                render() {
                    return <Child name={this.state.name}/>;
                }
            }
            ReactDOM.render(<Parent />, document.getElementById('app'));

        // Child.js     - stateless component class
            import React from 'react';
            export class Child extends React.Component {
                render() {
                    return <h1>Hey, my name is {this.props.name}!</h1>;
                }
            }
    A React component should use 'props' to store information that can be changed, but can only be changed by a different component.
    A React component should use 'state' to store information that the component itself can change.
    
    > child component will update the state of the parent component -> how? answer: define a state-changing method on the parent.
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { ChildClass } from './ChildClass';
        class ParentClass extends React.Component {
            constructor(props) {
                super(props);
                this.state = { totalClicks: 0 };
                this.handleClick = this.handleClick.bind(this);
            }
            handleClick() {                             // calling handleClick will result in a state change:
                const total = this.state.totalClicks;
                this.setState(
                    { totalClicks: total + 1 }
                );
            }
            // The stateful component class passes down handleClick to a stateless component class:
            render() {
                return (
                    <ChildClass onClick={this.handleClick} />
                );
            }
        }

        export class ChildClass extends React.Component {
            render() {
                return (
                    // When a user clicks on the <button></button>, a click event will fire. This will make the passed-down function get called, which will update the parent’s state.
                    <button onClick={this.props.onClick}>Click Me!</button>
                );
            }
        }
        -------------
        Another Example:
        // Parent.js
            import React from 'react';
            import ReactDOM from 'react-dom';
            import { Child } from './Child';
            class Parent extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = { name: 'Frarthur' };
                    this.changeName = this.changeName.bind(this);
                }
                changeName(newName){
                    this.setState({name: newName})
                }
                render() {
                    return <Child name={this.state.name} onChange={this.changeName}/>
                }
            }
            ReactDOM.render(<Parent />, document.getElementById('app'));

        // Child.js
            import React from 'react';
            export class Child extends React.Component {
                constructor(props){
                    super(props);
                    this.handleChange = this.handleChange.bind(this);
                }
                handleChange(e){
                    const name = e.target.value;
                    this.props.onChange(name);
                }
                render() {
                    return (
                        <div>
                            <h1>Hey my name is {this.props.name}!</h1>
                            <select id="great-names" onChange={this.handleChange}>
                                <option value="Frarthur">Frarthur</option>
                                <option value="Gromulus">Gromulus</option>
                                <option value="Thinkpiece">Thinkpiece</option>
                            </select>
                        </div>
                    );
                }
            }
    
    > Child Components Update Sibling Components.
    A child component updates its parent’s state, and the parent passes that state to a sibling component.
        In the previous example, Child had two jobs:
            1 - Child displayed a name.
            2 - Child offered a way to change that name.
        You should divide Child in two: one component for displaying the name, and a different component for allowing a user to change the name.

        // Parent.js
            import { Sibling } from './Sibling';
            ...
            return (	
                <div>	
                    <Child onChange={this.changeName} />	
                    <Sibling name={this.state.name}/>	
                </div>	
            );
        // Child.js
            remove <h1>Hey my name is {this.props.name}!</h1>
        // Sibling.js
            import React from 'react';
            export class Sibling extends React.Component {
                render() {
                    const name = this.props.name;
                    return (
                        <div>
                            <h1>Hey, my name is {name}!</h1>
                        </div>
                    );
                }
            }

    -------------------- Ravenous: Part 3 --------------------
    -------------------- Ravenous: Part 4 --------------------
Authentication and OAuth 
        Authentication is the process used by applications to determine and confirm identities of users. 
        It ensures that the correct content is shown to users. More importantly, it ensures that incorrect 
        content is secured and unavailable to unauthorized users.
        
        Common design patterns for these interactions:
        - Password Authentication
            The most common implementation of authentication requires a user to input their username or email and a password. The application’s server then checks the supplied credentials to determine if the user exists and if the supplied password is correct.
            Typically, upon a successful login, the application will respond with an authentication token (or auth token) for the client to use for additional HTTP requests. This token is then stored on the user’s computer, preventing the need for users to continuously log in.
            This token generally expires after a certain amount of time, ensuring the correct user is using the application over time as well.
        - API Keys
            Sometimes the user is another application.
            Many apps expose interfaces to their information in the form of an API.
            The most basic pattern for API access from another application is using an API key.
            Public APIs usually provide a developer portal where you can register your application and generate a corresponding API key. This key is then unique to your application.
        - OAuth (e.g. signed into a web app with Google or Facebook)
            OAuth is an open standard and is commonly used to grant permission for applications to access user information without forcing users to give away their passwords.
            An open standard is a publicly available definition of how some functionality should work. However, the standard does not actually build out that functionality.
            As a result, each API is required to implement their own version of OAuth and therefore may have a slightly different implementation or flow. However, they’re all based around the same OAuth specification.
            - Generic OAuth Flow
            - OAuth 2
                - Client Credentials Grant
                - Authorization Code Grant
                - Implicit Grant (access token)

    -------------------- Advanced React --------------------
    You’ll be introduced to your second programming pattern: dividing components into presentational components and container components.
    
    1) Style
        > Inline Styles (written as an attribute)
            <h1 style={{ color: 'red' }}>Hello world</h1>
            Notice the double curly braces:
                The outer curly braces inject JavaScript into JSX. 
                The inner curly braces create a JavaScript object literal.
        > Style Object Variable
            const style = {                         // The style object
                color: 'darkcyan',
                background: 'mintcream'
            };
            <h1 style={styles}>Hello world</h1>     // then injected 

            Defining a variable named style in the top-level scope would be an extremely bad idea in many JavaScript environments! In React, however, it’s totally fine.
            Remember that every file is invisible to every other file, except for what you choose to expose via module.exports. You could have 100 different files, all with global variables named style, and there could be no conflicts.
        Style Name Syntax
            In regular JavaScript, style names are written in hyphenated-lowercase.
            In React, those same names are instead written in camelCase.
        Style Value Syntax
            In regular JS, style values are almost always strings.
            In React, if you write a style value as a number, then the unit "px" is assumed, e.g. { fontSize: 30 }.
            If you want to use units other than “px,” you can use a string, e.g. { fontSize: "2em" }
        Share Styles Across Multiple Components
            One way to make styles reusable is to keep them in a separate JavaScript file. This file should export the styles that you want to reuse, via export. You can then import your styles into any component that wants them.
    
    2) Container Components From Presentational Components
        Second programming pattern: separating presentational components from display components.
        How can you tell when a component has too many responsibilities? -> Separating container components 
        from presentational components helps to answer that question. It shows you when it might be a good 
        time to divide a component into smaller components. It also shows you how to perform that division.
        
        Idea: if a component has to have state, make calculations based on props, or manage any other complex logic, 
        then that component shouldn’t also have to render HTML-like JSX. 
        Instead of rendering HTML-like JSX, the component should render another component.

        The container component does the work of figuring out what to display. 
        The presentational component does the work of actually displaying it. 
        If a component does a significant amount of work in both areas, then that’s a sign that you should use this pattern!

        How do you do that?
            - you already have /components/MyComponent.js
            - create /containers/MyComponentContainer.js
            - make a copy. After that, you can delete the appropriate parts from each copy.
                MyComponent.js and MyComponentContainer.js should be identical.
            - MyComponent.js is going to be your presentational component class     // to render HTML-like JSX.
                - delete import ReactDOM from 'react-dom'.
                - At the bottom of the file, delete the ReactDOM.render() call.
                - Export MyComponent    // a presentational component will always get rendered by a container component.
                - Delete everything inside of the GuineaPigs component class, except for the render function.
                    - delete any variables before return if exists (they are left in MyComponentContainer.js), replace with e.g. const src = this.props.src;
                    - delete variables that were defined before class if exists.
            - MyComponentContainer.js is going to be your container component class.
                - Import MyComponent 
                - change the component class’s name from MyComponent to MyComponentContainer.
                - In the ReactDOM.render call, change <MyComponent /> to <MyComponentContainer />.
                - Delete any HTML-like JSX from MyComponentContainer‘s render function’s return statement:
                    - remove all html, instead add <MyComponent />, pass props if exists.
            
            Example:
                // MyComponent.js
                import React from 'react';
                export class MyComponent extends React.Component {
                    render() {
                        const src = this.props.src;
                        return (
                            <div>
                                <h1>Cute Guinea Pigs</h1>
                                <img src={src} />
                            </div>
                        );
                    }
                }
                // MyComponentContainer.js
                import React from 'react';
                import ReactDOM from 'react-dom';
                import {MyComponent} from '../components/MyComponent'
                const GUINEAPATHS = [
                    'https://s3.amazonaws.com/codecademy-content/courses/React/react_photo-guineapig-1.jpg',
                    'https://s3.amazonaws.com/codecademy-content/courses/React/react_photo-guineapig-2.jpg',
                    'https://s3.amazonaws.com/codecademy-content/courses/React/react_photo-guineapig-3.jpg',
                    'https://s3.amazonaws.com/codecademy-content/courses/React/react_photo-guineapig-4.jpg'
                ];
                class MyComponentContainer extends React.Component {
                    constructor(props) {
                        super(props);
                        this.state = { currentGP: 0 };
                        this.interval = null;
                        this.nextGP = this.nextGP.bind(this);
                    }
                    nextGP() {
                        let current = this.state.currentGP;
                        let next = ++current % GUINEAPATHS.length;
                        this.setState({ currentGP: next });
                    }
                    componentDidMount() {
                        this.interval = setInterval(this.nextGP, 5000);
                    }
                    componentWillUnmount() {
                        clearInterval(this.interval);
                    }
                    render() {
                        let src = GUINEAPATHS[this.state.currentGP];
                        return (
                            <GuineaPigs src={src}/>
                        );
                    }
                }
                ReactDOM.render(<GuineaPigsContainer />, document.getElementById('app'));

    3) Stateless Functional Components
        When you separate a container component from a presentational component, the presentational component 
        will always end up like this: one render() function, and no other properties.
        If you have a component class with nothing but a render function, then you can rewrite that component class in a very different way. Instead of using React.Component, you can write it as a JavaScript function!
        A component class written as a function is called a stateless functional component.
            // component class 
            export class MyComponentClass extends React.Component {
                render() {
                    return <h1>Hello world</h1>;
                }
            }
            // stateless functional component:
            export const MyComponentClass = () => {
                return <h1>Hello world</h1>;
            }
        
        props
        Stateless functional components usually have props passed to them.
        To access these props, give your stateless functional component a parameter. 
        This parameter will automatically be equal to the component’s props object.
        It’s customary to name this parameter props.
            // component class:
            export class MyComponentClass extends React.Component {
                render() {
                    return <h1>{this.props.title}</h1>;
                }
            }

            // stateless functional component:
            export const MyComponentClass = (props) => {
                return <h1>{props.title}</h1>;
            }

    4) propTypes
        propTypes are useful for:
            - prop validation
                Validation can ensure that your props are doing what they’re supposed to be doing. If props are missing, 
                or if they’re present but they aren’t what you’re expecting, then a warning will print in the console.
            - documentation
                Documenting props makes it easier to glance at a file and quickly understand the component class inside.
        
        1. propTypes for component class:
            import React from 'react';
            export class MessageDisplayer extends React.Component {
              render() {
                return <h1>{this.props.message}</h1>;
              }
            }
            // This propTypes object should have one property for each expected prop:
            MessageDisplayer.propTypes = {
              message: React.PropTypes.string   // React.PropTypes.expected-data-type-goes-here
            };
            // Somewhere, at some time, this code is expected to execute: <MessageDisplayer message="something" />

            Another Example:
                Runner.propTypes = {
                    message:   React.PropTypes.string.isRequired,
                    style:     React.PropTypes.object.isRequired,
                    isMetric:  React.PropTypes.bool.isRequired,
                    miles:     React.PropTypes.number.isRequired,
                    milesToKM: React.PropTypes.func.isRequired,
                    races:     React.PropTypes.array.isRequired
                };
        2. propTypes for a stateless functional component:
            const Example = (props) => {
              return <h1>{props.message}</h1>;
            }
            Example.propTypes = {
              message: React.PropTypes.string.isRequired
            };

    5) React Forms
        Traditional form:   A user types some data into a form’s input fields, and the server doesn’t know about it. The server remains clueless until the user hits a “submit” button, which sends all of the form’s data over to the server simultaneously.
        React form:         you want the server to know about every new character or deletion, as soon as it happens. That way, your screen will always be in sync with the rest of your application.

            import React from 'react';
            import ReactDOM from 'react-dom';
            export class Input extends React.Component {
                constructor(props){
                    super(props);
                    this.state = {userInput: ''};                   // Set the Input's Initial State
                    this.handleUserInput = this.handleUserInput.bind(this);  
                }
                handleUserInput(e) {                                // Input Event Handler - event handler is function that gets called whenever a user enters or deletes any character.
                    this.setState({userInput: e.target.value})
                }
                render() {
                    return (
                        <div>
                            <input type="text" onChange={this.handleUserInput} value={this.state.userInput} />    // Input onChange, Update an Input's Value
                        </div>
                    );
                }
            }
            ReactDOM.render(<Input />, document.getElementById('app'));

        Controlled vs Uncontrolled component
            An uncontrolled component is a component that maintains its own internal state. 
            A controlled component is a component that does not maintain any internal state.
            Most React components are controlled.
            In React, when you give an <input /> a value attribute, then something strange happens: the <input /> BECOMES controlled. It stops using its internal storage. This is a more ‘React’ way of doing things.
            https://reactjs.org/docs/forms.html

        You just wrote your first React form.
        Notice that you didn’t use a submit button. You didn’t even use a <form> element! Your “form” was actually just an <input />.
        That won’t always be the case. You will still sometimes want a <form> element and a submit button, especially if you need to differentiate between a finished form and an in-progress form. But in some cases, it’s fine to have a “form” that is really just an input field.
        This is because, unlike in the traditional form paradigm, in React you re-send your form on every single character change. That removes the need to ever “submit” anything.

    -------------------- Lifecycle Methods -------------------- 
    Lifecycle methods are methods that get called at certain moments in a component’s life.
    Categories of lifecycle methods: 
        1. mounting, 
            A component “mounts” when it renders for the first time. This is when mounting lifecycle methods get called.
            When a component mounts, it automatically calls these three methods, in order.
            
            There are three mounting lifecycle methods:
            - componentWillMount
            - render
                render belongs to two categories: mounting lifecycle methods, and updating lifecycle methods. 
            - componentDidMount
                componentDidMount gets used a lot!
                If your React app uses AJAX to fetch initial data from an API, then componentDidMount is the place to make that AJAX call. 
                More generally, componentDidMount is a good place to connect a React app to external applications, such as web APIs or JavaScript frameworks. 
                componentDidMount is also the place to set timers using setTimeout or setInterval.
        2. updating,
            - componentWillReceiveProps
                When a component instance updates, componentWillReceiveProps gets called before the rendering begins.
                componentWillReceiveProps only gets called if the component will receive props.
                componentWillReceiveProps automatically gets passed one argument: an object called nextProps. 
                nextProps is a preview of the upcoming props object that the component is about to receive.
            - shouldComponentUpdate
                shouldComponentUpdate should return either true or false.
                If shouldComponentUpdate returns true, then nothing noticeable happens. 
                But if shouldComponentUpdate returns false, then the component will not update!
                shouldComponentUpdate automatically receives two arguments: nextProps and nextState.
            - componentWillUpdate
                componentWillUpdate receives two arguments: nextProps and nextState.
                The main purpose of componentWillUpdate is to interact with things outside of the React architecture. If you need to do non-React setup before a component renders, such as checking the window size or interacting with an API, then componentWillUpdate is a good place to do that.
            - render
            - componentDidUpdate
                When a component instance updates, componentDidUpdate gets called after any rendered HTML has finished loading.
                componentDidUpdate automatically gets passed two arguments: prevProps and prevState. 
                componentDidUpdate is usually used for interacting with things outside of the React environment, like the browser or APIs. It’s similar to componentWillUpdate in that way, except that it gets called after render instead of before.
        3. unmounting
            A component’s unmounting period occurs when the component is removed from the DOM. This could happen if the DOM is rerendered without the component, or if the user navigates to a different website or closes their web browser.
            - componentWillUnmount is the only unmounting lifecycle method!
            componentWillUnmount gets called right before a component is removed from the DOM.

    -------------------- Project: Jammming --------------------
    You will use your knowledge of React components, passing state, and requests with the Spotify API to 
    build a website that allows users to search the Spotify library, create a custom playlist, then save it to their Spotify account.


************************************************************************************************
************************************************************************************************
************************************************************************************************

11. JavaScript Back-End Development
    In order to have consistent ways of interacting with data, a back-end will often include a web API. 
    API stands for Application Program Interface and can mean a lot of different things, but 
    a web API is a collection of predefined ways of, or rules for, interacting with a web application’s data, 
    often through an HTTP request-response cycle. 

    Two other concepts we’ll want our server-side logic to handle are authentication and authorization.
        Authentication:
        - use logins with usernames and passwords (need to be securely stored in the back-end on a database).  
        - use external resources for authentication.

    There are numerous back-end frameworks:
        PHP: Laravel
        JS: Express.js
        Ruby: Ruby on Rails
        Java: Spring, JSF
        Python: Flask, Django

    The collection of technologies used to create the front-end and back-end of a web application is referred to as a stack. This is where the term full-stack developer comes from.
    The MEAN stack is a technology stack for building web applications that uses MongoDB, Express.js, AngularJS, and Node.js.
    The LAMP Stack uses Linux, Apache, MySQL, and PHP.

    -------------------- Node.js --------------------
    Node.js is a JavaScript runtime, or an environment that allows us to execute JavaScript code outside of the browser.
    > node -v

    REPL is an abbreviation for read–eval–print loop. It’s a program that loops, or repeatedly cycles, through 
    three different states: a read state where the program reads input from a user, the eval state where the 
    program evaluates the user’s input, and the print state where the program prints out its evaluation to a 
    console. Then it loops through these states again.
    When you install Node, it comes with a built-in JavaScript REPL. You can access the REPL by:
    > node
    > global    // or console.log(global)
    > Object.keys(global)
        [
            'global',
            'process,
            'Buffer',
            'clearImmediate',
            'clearInterval',
            'clearTimeout',
            'setImmediate',
            'setInterval',
            'setTimeout',
            'console',
            'module',
            'require'
        ]
    > node myFile.js

    Process
    In computer science, a process is the instance of a computer program that is being executed. 
    To see information about the various processes running on your computer right now:
        Windows machine: Task Manager
        Mac: Activity Monitor
    
    - process.env property is an object which stores and controls information about the environment in which the process is currently running. 
        if (process.env.NODE_ENV === 'development'){
            console.log('Testing! Testing! Does everything work?');
        }
    - process.memoryUsage()
    - process.memoryUsage().heapUsed
        Heap can mean different things in different contexts: 
            a heap can refer to a specific data structure, but 
            it can also refer to the a block of computer memory.
    - process.argv    
        > node myProgram.js testing several features
        > console.log(process.argv[3]); // Prints 'several'  

    1) Core Modules
        let events = require('events');
    2) Local Modules
        // dog.js
        module.exports = class Dog {
            constructor(name) {
                this.name = name;
            }
            praise() {
                return `Good dog, ${this.name}!`;
            }
        };
        // app.js
        let Dog = require('./dog.js');
        const tadpole = new Dog('Tadpole');
        console.log(tadpole.praise());
    3) Third-party modules
        npm: express, react, nodemon

    Event-Driven Architecture
        let events = require('events');
        let myEmitter = new events.EventEmitter();
        let newUserListener = (data) => {console.log(`We have a new user: ${data}.`);};
        myEmitter.on('new user', newUserListener)   // Assign the newUserListener function as the listener callback for 'new user' events
        myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad' // Emit a 'new user' event

        The synchronous code from the while-loop will always fill the stack!  If we wanted to avoid the infinite 
        loop, we could replace the while-loop with an asynchronous function— e.g., the Node setInterval() API.
        Note: The modern way of handling asynchronous tasks is through JavaScript Promises 
        (developers also favor the newer async...await syntax). 
    
    User Input/Output
        process.stdin.on('data', (userInput) => {
            let input = userInput.toString()
            console.log(input)
        });

    Errors
        - EvalError
        - SyntaxError
        - RangeError
        - ReferenceError
        - TypeError
        - URIError

        Error handling techniques such as try...catch statements.

        Error-first callback functions:
            const errorFirstCallback = (err, data)  => {
                if (err) {
                    console.log(`There WAS an error: ${err}`);
                } else {
                    // err was falsy
                    console.log(`There was NO error. Event data: ${data}`);
                }
            }

    Filesystem
        When running JavaScript code on a browser, it’s important for a script to have only limited access to a 
        user’s filesystem. This technique of isolating some applications from others is known as sandboxing. 
        Sandboxing protects users from malicious programs and invasions of privacy.

        const fs = require('fs');   
        let readDataCallback = (err, data) => {     // error-first callback function
            if (err) {
                console.log(`Something went wrong: ${err}`);
            } else {
                console.log(`Provided file contained: ${data}`);
            }
        };
        fs.readFile('./file.txt', 'utf-8', readDataCallback);

    Create an HTTP Server
        http module
        http.createServer() method returns an instance of an http.server. 
        http.server has a method .listen() which causes the server to “listen” for incoming connections. 

        EXAMPLE 1. Start a web server which only serve the string ‘Hello World!\n
        const http = require('http');
        let requestListener = (request, response) => {
            response.writeHead(200, {'Content-Type': 'text/plain' });
            response.write('Hello World!\n');
            response.end();
        };
        const server = http.createServer(requestListener);
        server.listen(3000);

        Visit http://localhost:3000/

        EXAMPLE 2. Start a web server which serve some HTML
        // app.js
        const http = require('http');
        let {requestListener} = require('./callbackFile.js');
        const PORT = process.env.PORT || 4001;
        let server = http.createServer(requestListener)
        server.listen(PORT)

        // callbackFile.js
        const fs = require('fs');
        module.exports = {
            requestListener: (req, res) => {
                fs.readFile('./myWebsite.html',  'utf-8', (err, data) => {
                    if (err){
                        res.writeHead(200, {'Content-Type': 'text/html'});
                        res.write(`${err}`);
                        res.end();
                    } else {
                        res.writeHead(200, {'Content-Type': 'text/html'});
                        res.write(data);
                        res.end(); 
                    }
                })
            }
        }

        // myWebsite.html
        <!DOCTYPE html>
        <html lang="en">

        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>My Website</title>
        </head>

        <body>
            <h1>I'm hosting this website with my own Node web server</h1>
            <h2>Pretty exciting stuff...</h2>              
        </body>

        </html>

    -------------------- Express --------------------
    -------------------- REST (REpresentational State Transfer) --------------------
    REST is an architectural style for providing standards between computer systems on the web, making it easier 
    for systems to communicate with each other. REST-compliant systems, often called RESTful systems, are 
    characterized by how they are stateless and separate the concerns of client and server. 
    - Separation of Client and Server
    - Statelessness

    1) Client make Request:
    A request generally consists of:
        - an HTTP verb, which defines what kind of operation to perform
            GET — retrieve a specific resource (by id) or a collection of resources
            POST — create a new resource
            PUT — update a specific resource (by id)
            DELETE — remove a specific resource by id
        - a header, which allows the client to pass along information about the request
            Accept parameters(type/subtype):
                text/html, text/css, text/plain
                image/png, image/jpeg, image/gif
                audio/wav, image/mpeg
                video/mp4, video/ogg
                application/json, application/pdf, application/xml, application/octet-stream
        - a path to a resource
        - an optional message body containing data
    
    2) Server Sending Responses
        Content Types
        Response Codes
                     Status code	                Meaning
            GET, PUT 200 (OK)	                standard response for successful HTTP requests.
            POST     201 (CREATED)	            standard response for an HTTP request that resulted in an item being successfully created.
            DELETE   204 (NO CONTENT)	        standard response for successful HTTP requests, where nothing is being returned in the response body.
                     400 (BAD REQUEST)	        The request cannot be processed because of bad request syntax, excessive size, or another client error.
                     403 (FORBIDDEN)	            The client does not have permission to access this resource.
                     404 (NOT FOUND)	            The resource could not be found at this time. It is possible it was deleted, or does not exist yet.
                     500 (INTERNAL SERVER ERROR)	The generic answer for an unexpected failure if there is no more specific information available.

    Examples:
    To view all customers:
        request
            GET http://fashionboutique.com/customers    or GET http://fashionboutique.com/customers/123
            Accept: application/json
        response    
            Status Code: 200 (OK)
            Content-type: application/json
    To create a new customer:
        request
            POST http://fashionboutique.com/customers
            Body:
            {
                “customer”: {
                    “name” = “Scylla Buss”
                    “email” = “scylla.buss@codecademy.org”
                }
            }
        response    
            201 (CREATED)
            Content-type: application/json
    To update that customer:
        request
            PUT http://fashionboutique.com/customers/123
            Body:
                {
                “customer”: {
                    “name” = “Scylla Buss”
                    “email” = “scyllabuss1@codecademy.com”
                }
            }
        response    
            Status Code: 200 (OK)
    To delete that customer:
        request
            DELETE http://fashionboutique.com/customers/123
        response    
            Status Code: 204 (NO CONTENT)

    Practice with REST
        The site has an index.html and a style.css. Each user has a username and a password. Each photo has a venue and an owner. Each venue has a name and street address. 
        Can you design a REST system that would accommodate:
        - storing users, photos, and venues
        - accessing venues and accessing certain photos of a certain venue

        Possible Solution - Models
        {
            “user”: {
                "id": <Integer>,
                “username”: <String>,
                “password”:  <String>
            }
        }
            {
            “photo”: {
                "id": <Integer>,
                “venue_id”: <Integer>,
                “author_id”: <Integer>
            }
        }
            {
            “venue”: {
                "id": <Integer>,
                “name”: <String>,
                “address”: <String>
            }
        }
        Possible Solution - Requests/Responses
        GET Requests
        Request- GET /index.html Accept: text/html Response- 200 (OK) Content-type: text/html
        Request- GET /style.css Accept: text/css Response- 200 (OK) Content-type: text/css
        Request- GET /venues Accept:application/json Response- 200 (OK) Content-type: application/json
        Request- GET /venues/:id Accept: application/json Response- 200 (OK) Content-type: application/json
        Request- GET /venues/:id/photos/:id Accept: application/json Response- 200 (OK) Content-type: image/png

        POST Requests
        Request- POST /users Response- 201 (CREATED) Content-type: application/json
        Request- POST /venues Response- 201 (CREATED) Content-type: application/json
        Request- POST /venues/:id/photos Response- 201 (CREATED) Content-type: application/json

        PUT Requests
        Request- PUT /users/:id Response- 200 (OK)
        Request- PUT /venues/:id Response- 200 (OK)
        Request- PUT /venues/:id/photos/:id Response- 200 (OK)

        DELETE Requests
        Request- DELETE /venues/:id Response- 204 (NO CONTENT)
        Request- DELETE /venues/:id/photos/:id Response- 204 (NO CONTENT)

        -------------------- Express Routes --------------------
        const express = require('express');
        const app = express();
        const PORT = 4001;
        app.use(express.static('public'));  // optional. This is used to make sure that once the server is started, you can reload the browser.
        app.listen(PORT, () => {
            console.log(`Server is listening on port ${PORT}`);
        });

        Example: GET request (app.get), path. .send() response.
            const moods = [{ mood: 'excited about express!'}, { mood: 'route-tastic!' }];
            app.get('/moods', (req, res, next) => {
                // Here we would send back the moods array in response
                res.send(moods);
            });

        Express servers send responses using the .send() method on the response object. .send() will take any input and include it in the response body.
        In addition to .send(), .json() can be used to explicitly send JSON-formatted responses. .json() sends any JavaScript object passed into it.
        
        If there are no matching routes registered, or the Express server has not sent a response at the end of all 
        matched routes, it will automatically send back a 404 Not Found response, meaning that no routes were 
        matched or no response was ultimately sent by the registered routes.

        Getting A Single Expression
            const monsters = { hydra: { height: 3, age: 4 }, dragon: { height: 200, age: 350 } };
            // GET /monsters/hydra
            app.get('/monsters/:name', (req, res, next) => {
                console.log(req.params) // { name: 'hydra' };
                res.send(monsters[req.params.name]);
            });

        Setting Status Codes
        The res object has a .status() method to allow us to set the status code, and other methods like .send() can be chained from it.
            const monsterStoreInventory = { fenrirs: 4, banshees: 1, jerseyDevils: 4, krakens: 3 };
            app.get('/monsters-inventory/:name', (req, res, next) => {
                const monsterInventory = monsterStoreInventory[req.params.name];
                if (monsterInventory) {
                    res.send(monsterInventory);
                } else {
                    res.status(404).send('Monster not found');
                }
            });

        Other HTTP methods: PUT, POST, and DELETE. Express methods: app.put(), app.post(), and app.delete().
        Query strings appear at the end of the path in URLs, and they are indicated with a ? character. 
        e.g., in /monsters/1?name=chimera&age=1, the query string is name=chimera&age=1 and the path is /monsters/1/
        Query strings do not count as part of the route path. Instead, the Express server parses them into an object 
        and attaches it to the request body as req.query. e.g., the req.query object { name: 'chimera', age: '1' }.
            
            const monsters = { '1': { name: 'cerberus', age: '4'  } };
            // PUT /monsters/1?name=chimera&age=1
            app.put('/monsters/:id', (req, res, next) => {
                const monsterUpdates = req.query;
                monsters[req.params.id] = monsterUpdates;
                res.send(monsters[req.params.id]);
            });


            const expressions = [];
            app.post('/expressions', (req, res, next) => {
                const receivedExpression = createElement('expressions', req.query);
                if (receivedExpression) {
                    expressions.push(receivedExpression);
                    res.status(201).send(receivedExpression);
                } else {
                    res.status(400).send();
                }
            });

            app.delete('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                if (expressionIndex !== -1) {
                    expressions.splice(expressionIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

    Now you have all the tools you need to create a basic CRUD API! 
    With these skills and knowledge of the HTTP request-response cycle, you could implement an API for any project needing CRUD functionality. 
    You could build a trip planner, an address book, a grocery list, an image-sharing application, an anonymous message board, the sky’s the limit!

    app.js is getting too big! -> Solution: Express provide Routers -> Refactoring: separate our application into a file to handle all /expressions routes, and another to handle all /animals routes.

    We invoke .Router() method on the top-level Express import. To use a router, we mount it at a certain path using app.use() and pass in the router as the second argument. 

        const express = require('express');
        const app = express();
        const monsters = {
            '1': {
                name: 'godzilla',
                age: 250000000
            },
            '2': {
                Name: 'manticore',
                age: 21
            }
        }
        const monstersRouter = express.Router();
        app.use('/monsters', monstersRouter);   
        monstersRouter.get('/:id', (req, res, next) => {    // monstersRouter.get('/:id') matches the full path /monsters/:id.
            const monster = monsters[req.params.id];
            If (monster) {
                res.send(monster);
            } else {
                res.status(404).send();
            }
        });

    Generally, we will keep each router in its own file, and require them in the main application. 

        // monsters.js
        const express = require('express');
        const monstersRouter = express.Router();

        const monsters = {
            '1': {
                name: 'godzilla',
                age: 250000000
            },
            '2': {
                Name: 'manticore',
                age: 21
            }
        }
        monstersRouter.get('/:id', (req, res, next) => {
            const monster = monsters[req.params.id];
            if (monster) {
                res.send(monster);
            } else {
                res.status(404).send();
            }
        });
        module.exports = monstersRouter;


        // main.js
        const express = require('express');
        const app = express();
        const monstersRouter = require('./monsters.js');
        app.use('/monsters', monstersRouter);

    -------------------- Express Middleware --------------------
    Terms: code quality, code duplication, “Don’t Repeat Yourself” (DRY).
    Middleware is code that executes between a server receiving a request and sending a response.
    In Express, middleware is a function. Middleware can perform logic on the request and response objects, such as: 
        - inspecting a request, 
        - performing some logic based on the request, 
        - attaching information to the response, 
        - attaching a status to the response, 
        - sending the response back to the user, or 
        - simply passing the request and response to another middleware.

    Example of middleware in action:
        app.use((req, res, next) => {       // app.use() takes a callback function that it will call for every received request.
            console.log('Request received');
            // console.log(`${req.method} Request Received`);   // req.method property equal to the verb of the request!
        });
    
    An Express middleware is a function with three parameters: (req, res, next). The third argument to a 
    middleware function, next, should get explicitly called as the last part of the middleware’s body. 
    Express routes are middleware.
    
        app.use((req, res, next) => {
            console.log("A sorcerer approaches!");
            next();
        });
        app.get('/magic/:spellname', (req, res, next) => {
            console.log("The sorcerer is casting a spell!");
            next();
        });
        app.get('/magic/:spellname', (req, res, next) => {
            console.log(`The sorcerer has cast ${req.params.spellname}`);
            res.status(200).send();
        });
        app.get('/magic/:spellname', (req, res, next) => {
            console.log("The sorcerer is leaving!");
        });
        // Accessing http://localhost:4001/magic/fireball 
        // Console Output:
        // "A sorcerer approaches!"
        // "The sorcerer is casting a spell!"
        // "The sorcerer has cast fireball"

    In documentation for many programming languages, optional arguments for functions are placed in square brackets ([]). 
        app.use([path,] callback [, callback...])

        app.use('/sorcerer', (req, res, next) => {
            console.log('User has hit endpoint /sorcerer');
            next();
        });
        In the example above the console will print 'User has hit endpoint /sorcerer', if someone visits our 
        web page’s ‘/sorcerer’ endpoint. Since the method app.use() was used, it won’t matter if the user is 
        performing a GET,a POST, or any other kind of HTTP request. Since the path was given as an argument 
        to app.use(), this middleware function will not execute if the user hits a different path 
        (for instance: '/spells' or '/sorcerer/:sorcerer_id').

        next is called at the end of the middleware callback function. 
        Methods such as app.use(), app.get(), app.post(), and so on all can take multiple callbacks as additional parameters.
            app.get('/spells/:id', authenticate, getSpell);
            app.post('/spells', authenticate, validateData, createSpell);
            app.put('/spells/:id', authenticate, validateData, updateSpell);
        
        
        https://github.com/expressjs/morgan#api
        morgan, an open-source library for logging information about the HTTP request-response cycle in a 
        server application. morgan() is a function that will return a middleware function, to reiterate: 
        the return value of morgan() will be a function, that function will have the function signature 
        (req, res, next) that can be inserted into an app.use(), and that function will be called before all 
        following middleware functions. 

        const morgan = require('morgan')
        // Replace your logging middleware
            app.use((req, res, next) => {
                console.log(`${req.method} Request Received`);
                next();
            });
        // with morgan('tiny').
            app.use((req, res, next) => {
                morgan('tiny');
            });

        // Logging Middleware
        app.use(morgan('dev'));
        // Body Parsing Middleware
        app.use(bodyParser.json())
        // Error-Handling Middleware
        app.use((err, req, res, next) => {
            const status = err.status || 500;
            res.status(status).send(err.message);
        });
        Error handling middleware needs to be the last app.use() in your file. 
        If an error happens in any of our routes, we want to make sure it gets passed to our error handler. 
        The middleware stack progresses through routes as they are presented in a file, therefore the error handler should sit at the bottom of the file.
        // Replace
            if (!jellybeanBag[beanName]) {
                return res.status(404).send('Bean with that name does not exist');
            }
        // with
            if (!jellybeanBag[beanName]) {
                const error = new Error('Bean with that name does not exist')
                error.status = 404;
                return next(error);
            }

        List of Express Middleware https://expressjs.com/en/resources/middleware.html

        router.param()
            app.param('spiceRackId', (req, res, next, id) => {
                const idToFind = Number(id);
                const rackIndex = spiceRacks.findIndex(spiceRack => spiceRack.id === idToFind);
                if (rackIndex !== -1) {
                    req.spiceRack = spiceRacks[rackIndex];
                    req.spiceRackIndex = rackIndex;
                    next();
                } else {
                    res.status(404).send('Spice Rack Not Found.');
                }
            });
            app.get('/spice-racks/:spiceRackId', (req, res, next) => {
                res.send(req.spiceRack);
            });
        Merge Parameters:
            const sorcererRouter = express.Router();
            const familiarRouter = express.Router({mergeParams: true});
            sorcererRouter.use('/:sorcererId/familiars', familiarRouter);
            sorcererRouter.get('/', (req, res, next) => {
                res.status(200).send(Sorcerers);
                next();
            });
            sorcererRouter.param('sorcererId', (req, res, next, id) => {
                const sorcerer = getSorcererById(id);   
                req.sorcerer = sorcerer;
                next();
            });
            familiarRouter.get('/', (req, res, next) => {
                res.status(200).send(`Sorcerer ${req.sorcerer} has familiars ${getFamiliars(sorcerer)}`);
            });
            app.use('/sorcerer', sorcererRouter);

    -------------------- Unit Testing with Mocha and Chai --------------------
    Unit testing means testing the behavior of code in small, independent units.
    This is in comparison of integration testing, in which a set of modules are tested as a group.
    Mocha and Chai are two JavaScript frameworks commonly used together for unit testing.
    
    Mocha is a testing framework that provides functions that are executed according in a specific order, and that logs their results to the terminal window.
    When you read tests written in Mocha, you’ll see regular use of the keywords describe and it.
    A test suite is a collection of tests all relating to a single functionality or behavior. 
    A test case(often called ‘specs’) or a unit test is a single description about the desired behavior of the code that either passes or fails. 
    Test suites are batched underneath the 'describe' keyword, and test cases are batched under the 'it' keyword.

    The base component of test cases are assertions. Assertions are tied to particular values (whereas test cases are descriptions of behavior) and they will fail if the expected value does not match the actual value.
    The words 'should', 'expect', and 'assert' in the tests indicate that an assertion is being made.

    Chai is an assertion library that is often used alongside Mocha. 
    It provides functions and methods that help you compare the output of a certain test with its expected value.
    Example of a Chai assertion: expect(exampleArray).to.have.lengthOf(3);
    Try appending .only() or .skip() to your describe or it blocks in order to only run certain tests or skip other certain tests.
    The end of the log for a failed test case provides a number like 12:18. This indicates that the failed assertion started at line 12, character 18. 


    Hook - a function that is called at certain points in the lifecycle of the process that it is running in.

    -------------------- CORS --------------------
        security policies:
            - same-origin       a document (i.e., like a web page) hosted on server A can only interact with other documents that are also on server A. 
                                An origin is made up of the following three parts: the protocol, host, and port number.
            - cross-origin, which has evolved into the cross-origin resource sharing standard(CORS).
                                A request for a resource (like an image or a font) outside of the origin is known as a cross-origin request.       
                                CORS allows servers to specify who (i.e., which origins) can access the assets on the server, among many other things.                                
                                Most servers will allow GET requests. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent malicious behavior.
                                With CORS, a server can specify who can access its assets and which HTTP request methods are allowed from external resources.
                                The CORS standard manages cross-origin requests by adding new HTTP headers to the standard list of headers:
                                    -> Access-Control-Allow-Origin
                                            Many times, this value will be *, meaning that Server A will share the requested resources with any domain on the Internet. 
                                            Other times, the value of this header may be set to a particular domain (or list of domains), meaning that Server A will share its resources with that specific domain (or list of domains).
                                    - Access-Control-Allow-Credentials
                                    - Access-Control-Allow-Headers
                                    - Access-Control-Allow-Methods
                                    - Access-Control-Expose-Headers
                                    - Access-Control-Max-Age
                                    - Access-Control-Request-Headers
                                    - Access-Control-Request-Method
                                    - Origin
    How do I implement CORS?
    Implementing the request headers to set up CORS correctly depends on the language and framework of the backend.
    In Node:    response.setHeader('Content-Type', 'text/html');
    In Express(use CORS middleware):    
        > npm install cors
        var express = require('express');
        var cors = require('cors');
        var app = express();
        app.use(cors());
        app.get('/hello/:id', function (req, res, next) {
            res.json({msg: 'Hello world, we are CORS-enabled!'});
        });
        app.listen(80, function () {
            console.log('CORS-enabled web server is listening on port 80');
        });    

    -------------------- Cumulative Project: Boss Machine -------------------- 
    > npm i
    > npm run start     // to begin your server, script will automatically restart your server whenever you make changes to the server.js file or server/ folder.
    or > node server.js
    open index.html 
    // server.js
        - set up express middlewares: body-parser, cors.
        - mount the existing apiRouter at /api.
        - start the server listening on the provided PORT.
        - add routes - minions + work bonus, ideas with middleware, meetings - using f-ns from database

************************************************************************************************
************************************************************************************************
************************************************************************************************

12. SQL and Databases for Web Development
    DB: 
        - relational databases: MySQL, PostgreSQL 
        - non-relational(NoSQL) databases: MongoDB, Redis.

        SELECT * FROM browse LIMIT 10;
            * means all columns.
            LIMIT is a clause that lets you specify the maximum number of rows the result set will have.
        SELECT column1, column2 FROM table_name;
        SELECT name AS 'Titles' FROM movies;
            AS - to rename a column or table using an alias. (the columns are not being renamed in the table. The aliases only appear in the result).
        SELECT DISTINCT tools FROM inventory;
            DISTINCT is used to return unique values in the output. It filters out all duplicate values in the specified column(s).
        SELECT * FROM movies WHERE imdb_rating > 8;
                WHERE clause filters the result set to only include rows where the following condition is true.
            SELECT * FROM movies WHERE name LIKE 'Se_en';
            SELECT * FROM movies WHERE name LIKE 'A%';
                LIKE - to compare similar values. 
                    - The _ means you can substitute any individual character here without breaking the pattern.
                    - % is a wildcard character that matches zero or more missing letters in the pattern.
            SELECT name FROM movies WHERE imdb_rating IS NOT NULL;  // IS NULL
                It is not possible to test for NULL values with comparison operators, such as = and !=.
            SELECT * FROM movies WHERE year BETWEEN 1990 AND 1999;
            SELECT * FROM movies WHERE name BETWEEN 'A' AND 'J';
                When the values are text, BETWEEN filters the result set for within the alphabetical range.
            SELECT * FROM movies WHERE year BETWEEN 1990 AND 1999 AND genre = 'romance';
                AND combines the two conditions.
            SELECT * FROM movies WHERE year > 2014 OR genre = 'action';
        SELECT * FROM movies ORDER BY name;
        SELECT * FROM movies WHERE imdb_rating > 8 ORDER BY year DESC;
            ORDER BY is a clause that indicates you want to sort the result set by a particular column.
        SELECT name,
            CASE
                WHEN imdb_rating > 8 THEN 'Fantastic'
                WHEN imdb_rating > 6 THEN 'Poorly Received'
                ELSE 'Avoid at All Costs'
            END
        FROM movies;
            CASE is SQL’s way of handling if-then logic.
            
    Common data types:
        - INTEGER, a positive or negative whole number
        - TEXT, a text string
        - DATE, the date formatted as YYYY-MM-DD
        - REAL, a decimal value

    CREATE TABLE celebs (
        id INTEGER, 
        name TEXT, 
        age INTEGER
    );

    INSERT INTO celebs (id, name, age)  VALUES (1, 'Justin Bieber', 22);
    SELECT statements always return a new table called the result set.
    
    ALTER TABLE celebs ADD COLUMN twitter_handle TEXT;
        The ALTER TABLE statement adds a new column to a table.
        NULL represents missing or unknown data. Here, the rows that existed before the column was added have NULL (∅) values for twitter_handle.
    
    UPDATE celebs SET twitter_handle = '@taylorswift13' WHERE id = 4; 
    DELETE FROM celebs WHERE twitter_handle IS NULL;

    SQLite setup guide: https://www.codecademy.com/articles/what-is-sqlite
        Try typing sqlite3 newdb.sqlite. If you’re presented with a sqlite> prompt, you’ve installed SQLite! 

    Constraints that add information about how a column can be used are invoked after specifying the data type for a column. 
        - PRIMARY KEY
        - UNIQUE
        - NOT NULL
        - DEFAULT

        CREATE TABLE celebs (
            id INTEGER PRIMARY KEY, 
            name TEXT UNIQUE,
            date_of_birth TEXT NOT NULL,
            date_of_death TEXT DEFAULT 'Not Applicable'
        );

    Data Analysts do the following:
            - Writing basic queries
            - Calculating aggregates
            - Combining data from multiple tables
            - Creating usage funnels
            - Analyzing user churn
            - Determining web traffic attribution
        -> funnel - воронка, data analyst wants to determine what percent of users make it through each step of the funnel so that data analyst can recommend improvements to the website.
        -> A churn rate is the percent of subscribers to a monthly service who have canceled. 
            churn rate = cancellations / total subscribers
        -> UTM Parameters are special tags that site owners add to their pages to track what website a user was on before they reach the website. 
            e.g. utm_source = ‘google’.     // through Google search
                 utm_source = ‘facebook’.   // user clicked a Facebook ad 

    -------------------- SQL Calculations --------------------
    Calculations performed on multiple rows of a table are called aggregates.
    Aggregates:
        COUNT(): count the number of rows
        SUM(): the sum of the values in a column
        MAX()/MIN(): the largest/smallest value
        AVG(): the average of the values in a column
        ROUND(): round the values in the column

    GROUP BY is a clause in SQL that is used with aggregate functions.
    HAVING is very similar to WHERE. We can’t use WHERE here because we don’t want to filter the rows; we want to filter groups.

    SELECT COUNT(*) FROM table_name;
    SELECT SUM(downloads) FROM fake_apps;
    SELECT MAX(downloads) FROM fake_apps;
    SELECT AVG(downloads) FROM fake_apps;
    SELECT ROUND(price, 0) FROM fake_apps;
    SELECT year, AVG(imdb_rating) FROM movies GROUP BY year ORDER BY year;
    SELECT year, genre, COUNT(name) FROM movies GROUP BY 1, 2 HAVING COUNT(name) > 10;

    -------------------- Multiple SQL Tables --------------------
    One table:
        order_id
        customer_id
        customer_name
        customer_address
        subscription_id
        subscription_description
        subscription_monthly_price
        subscription_length
        purchase_date
    Should be 3 tables:
        orders: order_id, customer_id, subscription_id, purchase_date
        subscriptions: subscription_id, description, price_per_month, subscription_length
        customers: customer_id, customer_name, address

    Combining Tables with SQL (JOIN)
    INNER JOIN
        SELECT * FROM orders JOIN customers ON orders.customer_id = customers.customer_id;
        SELECT orders.order_id, customers.customer_name FROM orders JOIN customers ON orders.customer_id = customers.customer_id;
    A left join will keep all rows from the first table, regardless of whether there is a matching row in the second table.
        SELECT * FROM table1 LEFT JOIN table2 ON table1.c2 = table2.c2;
    When the primary key for one table appears in a different table, it is called a foreign key.
    CROSS JOIN lets us combine all rows of one table with all rows of another table.
        SELECT shirts.shirt_color, pants.pants_color FROM shirts CROSS JOIN pants;
    UNION stacks one dataset on top of another. Rules for appending data:
        - Tables must have the same number of columns.
        - The columns must have the same data types in the same order as the first table.
        SELECT * FROM table1 UNION SELECT * FROM table2;

    WITH allows us to define one or more temporary tables that can be used in the final query.
        WITH previous_results AS (SELECT ...    ...    ...    ... ) SELECT * FROM previous_results JOIN customers ON _____ = _____;

    -------------------- Project: Gold Medal Metrics --------------------
    > npm install 
    > npm run webpack   // to compile the front-end files
    > open index.html
    > node server.js    // To start your server
    Write a series of js f-ns that return the SQL queries in sql.js
    > npm test

************************************************************************************************
************************************************************************************************
************************************************************************************************

13. Building a Persistent API
    -------------------- Node-SQLite --------------------
    Opening A Database:
        const sqlite3 = require('sqlite3'); // import a module.  This code gives us a js object, called sqlite3 that we can interact with via methods.
        const db = new sqlite3.Database('./db.sqlite'); // method that opens up a new database, path to the file that SQLite will use to save the database

    To execute a query and retrieve all rows returned, we use db.all(), like so:
        db.all("SELECT * FROM Dog WHERE breed='Corgi'", (error, rows) => {
            printQueryResults(rows);
        });

    Retrieving A Single Row: 
        With a tiny database, this might be OK:
            db.all("SELECT * FROM Dog", (error, rows) => {
                printQueryResults(rows.find(row => row.id === 1));
            });
        If the database is large(db.get() - will fetch a single row from a database):
            db.get("SELECT * FROM Dog WHERE owner_name = 'Charlie'", (error, row) => {
                printQueryResults(row); 
            });

    Using Placeholders:
        const furLength1 = "short";
        const furLength2 = "long";
        const furColor1 = "brown";
        const furColor2 = "grey";

        const findDogByFur = (length, color) => {
            db.all(
                "SELECT * FROM Dog WHERE fur_length = $furLength AND fur_color = $furColor", 
                {
                    $furLength: length,
                    $furColor: color
                }, 
                (error, rows) => {
                    printQueryResults(rows);
                }
            );
        });

        findDogByFur(furLength1, furColor1); // prints all dogs with short brown fur.
        findDogByFur(furLength2, furColor1); // prints all dogs with long brown fur.
        findDogByFur(furLength1, furColor2); // prints all dogs with short grey fur.
        findDogByFur(furLength2, furColor2); // prints all dogs with long grey fur
    
    Using db.run()
    To perform SQL commands that do not return rows, we use db.run() to run the command.
    The SQL syntax for inserting is:
        INSERT INTO TableName (col_1_name, col_2_name, ...) VALUES (val_1, val2, ...);

    Handling Errors Gracefully.

    Using db.each():
        db.each("SELECT * FROM Dog WHERE breed = 'Labrador'", 
        (error, row) => {
            console.log(`${row.name} is a good dog`);   // This gets called for every row our query returns
        },
        (error, numberOfRows) => {
            console.log(`There were ${numberOfRows} good dogs`);    // This gets called after each of our rows have been processed
        });

    Creating A New Table
        db.run('INSERT INTO Average (year, temperature) VALUES ($year, $temp)', 
            {
					$year: row.year,
        	        $temp: row.temperature
      	    }, err => {
                if (err) {
                    console.log(err);
                }
            });

    Serial Queries
    One way, write all code in nested callbacks:
        db.run("DROP TABLE Dog", error => {
            db.run("CREATE TABLE Dog", error => {
                db.run("INSERT INTO Dog (breed, name, owner, fur_color, fur_length) VALUES ('Dachschund', 'Spike', 'Elizabeth', 'Brown', 'Short')", error => {}
            }
        }
    Another way, using the db.serialize() method:
        db.serialize(() => {                                                                                                                          
            db.run("DROP TABLE Dog");   // 1. remove the table Dog if it exists.
            db.run("CREATE TABLE Dog"); // 2. create an empty table named Dog.
            db.run("INSERT INTO Dog (breed, name, owner, fur_color, fur_length) VALUES  ('Dachshund', 'Spike', 'Elizabeth', 'Brown', 'Short')");
        });

    -------------------- Persistent API Cumulative Projects --------------------
    When we are building APIs, we want our models to provide four basic types of functionality:
        - CRUD: Create, Read, Update, and Delete resources.
    In a REST environment, CRUD often corresponds to the HTTP methods POST, GET, PUT, and DELETE, respectively. 
        - To create resources in a REST environment- use the HTTP POST method. 
            Request: POST http://www.myrestaurant.com/dishes/
            Body -
                {
                    "dish": {
                        "name": “Avocado Toast”,
                        "price": 8
                    }
                }
            Upon successful creation, the server should return a header with a link to the newly-created resource, 
            along with a HTTP response code of 201 (CREATED).
        - To read resources in a REST environment - use the GET method.
            Request: GET http://www.myrestaurant.com/dishes/
            Response: Status Code - 200 (OK)
            Body -
                {
                    "dishes": [
                        {
                        "id": 1,
                        "name": “Spring Rolls”,
                        "price": 6
                        },
                        {
                        "id": 2,
                        "name": “Mozzarella Sticks”,
                        "price": 7
                        },
                        ...
                        {
                        "id": 1223,
                        "name": “Avocado Toast”,
                        "price": 8
                        },
                        {
                        "id": 1224,
                        "name": “Muesli and Yogurt”,
                        "price": 5
                        }
                    ]
                }
            GET requests can also be used to read a specific item, when its id is specified in the request:
                Request: GET http://www.myrestaurant.com/dishes/1223
                Response: Status Code - 200 (OK) Body -
                {
                    "id": 1223,
                    "name": “Avocado Toast”,
                    "price": 8
                }
        - PUT is the HTTP method used for the CRUD operation, Update.
            Request: PUT http://www.myrestaurant.com/dishes/1223
            Body -
                {
                    "dish": {
                        "name": “Avocado Toast”,
                        "price": 10
                    }
                }
        - The CRUD operation Delete corresponds to the HTTP method DELETE. 
            Request: DELETE http://www.myrestaurant.com/dishes/1223
            Response: Status Code - 204 (NO CONTENT) 
            Body - None

    -------------------- Cumulative Project: Codestrips --------------------
    Let’s build an API for Codestrips! Codestrips is a small application to allow users to create and save small one-pane comic strips.
    > npm i express
    > npm install body-parser   // body-parsing middleware to parse JSON bodies.
    > node app.js   // start your server
    app.js
        const express = require('express')
        const bodyParser = require('body-parser')

        const app = express();  // Create a server
        const PORT = process.env.PORT || 4001;
        app.use(bodyParser.json());
        app.use(express.static('public'));
        app.listen(port, () => console.log(`Example app listening at http://localhost:${port}`))

        module.exports = app;
    > npm i sqlite3
    > node sql.js   // Run the file to create an empty Strip table
    > node seed.js  // After creating the database, you can add two test strips to the database
    sql.js
        const sqlite3 = require('sqlite3')
        const db = new sqlite3.Database('./db.sqlite')

        db.serialize(()=>{
            db.run('DROP TABLE IF EXISTS Strip')
            db.run(`CREATE TABLE IF NOT EXISTS Strip(
                id INTEGER PRIMARY KEY,
                head TEXT NOT NULL, 
                body TEXT NOT NULL, 
                background TEXT NOT NULL, 
                bubble_type TEXT NOT NULL, 
                bubble_text TEXT NOT NULL DEFAULT "", 
                caption TEXT NOT NULL DEFAULT ""
            )`)
        })
    app.js - add:
        const sqlite3 = require('sqlite3')
        const db = new sqlite3.Database(process.env.TEST_DATABASE || './db.sqlite');
        app.get('/strips', (req, res, next) => {
            db.all('SELECT * FROM Strip', (err, rows) => {
                if (err) {
                res.sendStatus(500);
                } else {
                res.send({strips: rows});
                }
            });
        });

        const validateStrip = (req, res, next) => {
            const stripToCreate = req.body.strip;
            // head, body, background, and bubbleType are required.
            // Send a 400 status code if any of the required values are not present in the request.
            if (!stripToCreate.head || !stripToCreate.body || !stripToCreate.bubbleType ||
                !stripToCreate.background) {
                return res.sendStatus(400);
            }
            next();
        }

        app.post('/strips', validateStrip, (req, res, next) => {
            const stripToCreate = req.body.strip;
            db.run(`INSERT INTO Strip (head, body, bubble_type, background, bubble_text,
                caption) VALUES ($head, $body, $bubbleType, $background, $bubbleText,
                $caption)`,
            {
                $head: stripToCreate.head,
                $body: stripToCreate.body,
                $bubbleType: stripToCreate.bubbleType,
                $background: stripToCreate.background,
                $bubbleText: stripToCreate.bubbleText,
                $caption: stripToCreate.caption,
            }, function(err) {
                if (err) {
                    return res.sendStatus(500);
                }
                db.get(`SELECT * FROM Strip WHERE id = ${this.lastID}`, (err, row) => {
                    if (!row) {
                        return res.sendStatus(500);
                    }
                    res.status(201).send({strip: row});
                });
            });
        });
        
    seed.js
        const sqlite3 = require('sqlite3');
        const db = new sqlite3.Database('./db.sqlite');

        db.serialize(() => {
        db.run(`INSERT INTO Strip (head, body, background, bubble_type, bubble_text, caption)
                VALUES ('happy', 'x', 'boat', 'statement', 'Beautiful day to sail to code island',
                'A Great Day')`, (err) => {
                    if (err) {
                    throw err;
                    }
                });
        db.run(`INSERT INTO Strip (head, body, background, bubble_type, bubble_text, caption)
                VALUES ('angry', 'plus', 'space', 'sound', 'What do aliens on the metric system say?
                Take me to your liter!', 'Cosmic Jokes')`, (err) => {
                    if (err) {
                    throw err;
                    }
                });
        db.all('SELECT * FROM Strip', (err, rows) => {
            if (err) {
            throw err;
            }
            console.log(`Finished seeding. There are ${rows.length} rows into the Strip table.`);
        });
        });

    -------------------- X-Press Publishing --------------------
    Setup Project
        > npm install
    Setup Server
        - create /server.js
        - npm i body-parser cors errorhandler morgan express
        - server.js
            const express = require('express');
            const bodyParser = require('body-parser')
            const cors = require('cors')
            const errorhandler = require('errorhandler')
            const morgan = require('morgan')

            const app = express()
            const PORT = process.env.PORT || 4000
            app.use(bodyParser.json())  // body-parser JSON middleware f-n for all routes in the server. 
            app.use(cors()) // CORS middleware f-n for all routes in the server. 

            // errorHandler middleware
            app.use(function (err, req, res, next) {
                console.error(err.stack)
                res.status(500).send('Something broke!')
                // res.status(500)
                // res.render('error', { error: err })
            })

            app.listen(PORT, () => {
                console.log('Listening on port: ' + PORT);
            });
            module.exports = app
    Create API Router
        - create /api/api.js
            const express = require('express');
            const apiRouter = express.Router()
            Export the router
        - server.js
            const apiRouter = require('./api/api');
            app.use('/api', apiRouter);
    Create Artist Table - ?? [couldn't install sqlite3]
        - migration.js
            Import sqlite3
        - database.sqlite
            const db = new sqlite3.Database('./database.sqlite');
            db.run('CREATE TABLE IF NOT EXISTS `Artist` ( ' +
                '`id` INTEGER NOT NULL, ' +
                '`name` TEXT NOT NULL, ' +
                '`date_of_birth` TEXT NOT NULL, ' +
                '`biography` TEXT NOT NULL, ' +
                '`is_currently_employed` INTEGER NOT NULL DEFAULT 1, ' +
                'PRIMARY KEY(`id`) )');
            > node migration.js
            > npm test
    Create Artist Routes: CRUD
        - create /api/artists.js
            const express = require('express');
            const artistsRouter = express.Router();
            const sqlite3 = require('sqlite3')
            const db = new sqlite3.Database(process.env.TEST_DATABASE || './database.sqlite')
            module.exports = artistsRouter;
        - /api/api.js
            const artistsRouter = require('./artists.js');
            - mount the artists router at /artists
    - ...
    Solution: https://www.youtube.com/watch?v=qri-Rr0m5Is&feature=emb_title

    -------------------- Expresso --------------------
    > npm i
    > npm i express
    > node server.js    // copy path of index.html and insert it in browser to view local version of the site 
    > npm test

    server.js
        - install & import middlewares
        - import api router 
    migration.js
        - import sqlite3, declare db, create tables schemas
        > node migration.js
    /api/api.js


************************************************************************************************
************************************************************************************************
************************************************************************************************

14. Test-Driven Development with JavaScript
    Terms: manual testing, automated testing, test suite, bug, documentation, and regression.

    Software testing: 
        - Manual testing
            > npm start
            EXAMPLE. Manually test the web app by following the list provided:
                Behavior 1: Run npm start in the terminal and reload the page. Scroll down and expect the webpage to start with a blank order.
                Behavior 2: Type a name and click “Place Order”. Scroll down and expect “Deliver to:” to display the submitted name.
                Behavior 3: A blank name will not overwrite the existing name.
                Behavior 4: Select a cake type and place the order. Expect “Cake” to display the selected cake type.
                Behavior 5: Check some fillings. Expect “Fillings” to display your selected fillings.
                Behavior 6: Choose a stack size. Expect “Pancake Count:” to display the number equivalent to the stack size, e.g. “Double” is “2”.
        - Automated Testing
            > npm test
            The workflow (of professional developers instead of testing team at the end of development) might look like this:
                1. Write code and corresponding tests
                2. Enter a command into a terminal to run tests
                3. If the app behaves as intended, all tests should pass. Development is complete.
                4. If it does not behave as intended, at least one test should fail. Fix code and return to step 2.
            Example:
                it('Orders can only be served on the hour, between 8:00 and 12:00', () => {
                    const earlyHr = '7:00';
                    const lateHr = '13:00';

                    browser.url('/');
                    const HTML = browser.getHTML('body');
                    const parseHTML = parseTextFromHTML(HTML, '#select-pickUp');
                    assert.notInclude(parseHTML, earlyHr);
                    assert.notInclude(parseHTML, lateHr);
                }); 
    Code:  
        - implementation code (code defining your app, e.g. written in index.js)  
        - test code (code defining your tests, e.g. written in index-test.js)
    Test suite - is a collection of tests for a web application. 
    Documentation.
    Regression.
        When adding a new feature to your product, it’s possible that something will break. 
        If that break occurs within a feature developed earlier, it is called regression. 
        When functionality previously developed and tested stops working, you may say the functionality regressed.
    
    -------------------- Mocha framework & Node.js assert library in JS --------------------
    https://mochajs.org/
        > npm init
        > npm install mocha -D  // -D notes that this package is a dependency for your project, which makes it easier for other developers to use
    Run Mocha:
        Way 1. 
            > ./node_modules/mocha/bin/mocha
        Way 2. (recommended) - add script to package.json.
            "scripts": {
                "test": "mocha"
            }
            > npm test
    Group tests using 👉'describe' fn & Define tests using 👉'it' fn. 
    Both the 'describe' and 'it' fns accept two parameters: a descriptive string and a callback function.
    Example:
        describe('Math', () => {
            describe('.max', () => {
                it('returns the argument with the highest value', () => {
                    // Your test goes here
                });
                it('returns -Infinity when no arguments are provided', () => {
                    // Your test goes here
                });
            });
        });
    
    Methods from Node’s assert library:
    - assert.equal()          performs a == comparison
    - assert.ok() 
    - assert.strictEqual()    performs a === comparison
    - assert.deepEqual()      to compare arrays or the values within two objects using loose (==) equality.
    - other methods: https://nodejs.org/api/assert.html

    // As a Node module, assert can be imported at the top of your files.
        const assert = require('assert');
    // You call assert functions like this:
        assert.ok(a === 3);     // if 'true', so no error is thrown. If 'false', an AssertionError is thrown.
    
    6 Characteristics of a good test: fast, complete, reliable, isolated, maintainable, and expressive. 
    https://www.codecademy.com/articles/tdd-u2-good-test

    // Naive approach
    describe('.pop', () => {
        it('returns the last element in the array [naive]', () => {
            assert.ok(['padawan', 'knight'].pop() === 'knight'); 
        });
    });

    // 3 phase approach (makes your test more reliable, maintainable, and expressive.)
    describe('.pop', () => {
        it('returns the last element in the array [3phase]', () => {
            // 1. Setup
            const knightString = 'knight';
            const jediPath = ['padawan', knightString];

            // 2. Exercise
            const popped = jediPath.pop();

            // 3. Verify
            assert.ok(popped === knightString);

            // 4. Teardown -(to make test isolated) reset any conditions that were changed during the test
            // Some tests require a fourth phase called teardown. It's used to reset the environment before the next test runs.
            // Some common changes to an environment include
            //    - changing read and write permissions on a file
            //    - altering files and directory structure
            //    - editing records in a database

        });
    });

    // 4 phase approach
    const assert = require('assert');
    const fs = require('fs');
    describe('appendFileSync', () => {
        it('writes a string to text file at given path name', () => {

            // Setup
            const path = './message.txt';
            const str = 'Hello Node.js';
            
            // Exercise: write to file
            fs.appendFileSync(path, str);

            // Verify: compare file contents to string
            // if you write 'readileSync' instead of 'readFileSync' --> you'll see TypeError
            // It prevented the execution of the teardown phase! This means the message.txt file won’t be deleted --> so we'll use hooks.
            const contents = fs.readFileSync(path);
            assert.ok(contents.toString() === str);

            // Teardown: delete path    // run the test suite twice and compare the outputs.
            fs.unlinkSync(path)
        });
    });

    A 👉hook is a piece of code that is executed when a certain event happens. Hooks can be used to set and 
    reset conditions like the setup and teardown phases do. In Mocha, a hook is written within a describe block.
    https://mochajs.org/#hooks

    describe('example', () => {
        afterEach(() => {
            // teardown goes here
        });

        it('.sample', () => {
            // test goes here
        });
    });
    In this example the function passed to afterEach is called after each it block is executed.
    The other hooks in the Mocha library are before(), beforeEach(), and after(). 

    -------------------- TDD --------------------
    Test-driven development (TDD) is a programming technique where you write test code before implementation code. 
    One of the driving forces of TDD is the red-green-refactor cycle (-> after that - consider edge cases.)
        Red signifies failing tests and green corresponds to passing tests.
        Refactor — Clean up and optimize code following the characteristics of a good test. Refactoring involves actively considering test and implementation code and making revisions to the code base. 
    At a high-level the process is:
        Write The Test -> Fail The Test -> Pass The Test -> Refactor Your Code 

    -------------------- The Testing Pyramid --------------------
    Most full-stack web applications include the following layers:
        - A view that appears in a user’s web browser
        - A server that handles HTTP requests
        - A database that stores information about user interactions
    
    1. (fast) Unit tests are isolated and fast tests that check one small behavior within your web application.
        e.g. we want to test whether our database can save a comment. Saving does not involve the view or server. 
    2. (slow) System tests are a group of fully integrated tests that exercise your entire web application.
        e.g. we want to test whether our blog renders with the correct post and comments. 
        This test exercises every layer of the web application:
            - The database stores the blog post.
            - The server sends the HTML to the browser.
            - The browser renders the view.
    3. (slower than system test but faster than unit tests) Integration tests include everything between unit tests and system tests. 
        e.g. check whether your web application can save a server-generated comment to the database. 
        This test integrates two layers of your web application:
            - The server receives the comment and sends it to the database.
            - The database stores your comment
        Developers often call tests like the one above 👉end-to-end tests, because they start in the browser (one end) and traverse the stack to the database (other end).
    
    The number and types of unit and integration tests that you write can be mapped onto the 👉testing pyramid.
    The testing pyramid is an approach to structuring your test suite.
        Browser-level integration tests more expensive than server-level tests.
        Server tests are more expensive than model tests.
        Model and database are the cheapest.
    
    Example
    Let’s consider the most efficient set of tests we could write to check that the browser renders only the last ten comments (under article on blog website).
    To support a ten-comment limit, we added 
        - one server test 
            - Calling a Comments.latest method returns a list of comments from your database that is ten items or less.
        - four model tests
            - A database with more than ten comments returns only ten.
            - A database with less than ten comments returns all of the comments.
            - A database with zero comments returns zero comments.
            - The list of comments is in reverse chronological order.

    When making decisions about how to test a feature, you should ask yourself a few of these questions:
        - Is a feature-level integration test necessary?
        - Can I test the same behavior with server and model layer tests?
        - How much confidence do I have with the server and model layer tests?
        - How long does the feature test take? Will that impact my team’s workflow?
    
    -------------------- Outside-in TDD --------------------
    Outside-in TDD is an approach that developers use to build full-stack web applications. 
    It leverages the same red, green, refactor steps, but with one caveat — a failing test does not always 
    inform you to write new implementation code. Instead, it may require that you implement new functionality 
    at a different level.

    Example: You have a movie blog and want to develop a feature that renders user comments under your blog posts. The application should render no more than ten comments when a user lands on the web page. The application should present the comments in reverse chronological order (i.e. the most recent comment should be first).
    Feature Testing
        Let’s use the following outside-in TDD approach:
            - Write a test that checks for the presence of a comment under a blog post.
            - The test fails, because your web application does not render comments.
            - Because your web application generates HTML at the server layer, you drop to the server to address the error.
            Although we could continue to write feature tests to check for the number of rendered comments, we know server tests are cheaper, so we can test those details when we drop a layer.
    Server Testing
        - Write a test that checks for the presence of a dynamically generated comment element in the server HTML.
        - The test fails, so we add implementation for a server-generated comment.
        - Once we’re in the green and consider refactoring, we want to write a test that calls a method at the model layer, let’s call it Comment.latest(). At the server layer, we’ll check if the method returns comments from the database.
        - Because this method doesn’t exist, we must drop to the model/database layer.
    Model and Database Testing
        - Write a test that checks if the Comment.latest method returns ten comments when the database has eleven comments.
        - Implement the Comment.latest method to return ten comments, so the test is green.
        - Once you’ve considered refactoring, write a test that checks whether the method returns the last ten comments in reverse chronological order.
        - Implement and refactor
        - Write a test that checks if Comment.latest() returns an empty array when your database is empty.
        - Implement and refactor
        - Write a test that checks if Comment.latest returns the correct number and order of comments when your database has between zero and ten comments in it.
        - Implement and refactor
    Refactoring Your Test Suite
        Consider the questions below when deciding how to refactor your suite:
            - How much longer does it take to run my test suite with these new tests?
            - Is the additional amount of time that your test suite takes to run acceptable?
            - Is there overlap between any of my new tests?
            - Is there overlap between my new tests and existing tests? 

    -------------------- Feature Testing With TDD --------------------
    Additional tools:
        - Chai https://www.chaijs.com/  - extends the types of assertions 
            const {assert} = require("chai")
            .include method
        - PhantomJS https://phantomjs.org/ - allows us to run an instance of a headless browser so you can run tests that mimic user interaction with a web application. 
        - WebdriverI/O https://webdriver.io/docs/gettingstarted.html - provides the methods to interact with browser values programmatically.
            global 'browser' variable -  gives us access to the browser
            browser.url() to simulate a user visiting the home page of our application, which is the first behavior we want to test.
            .getText method
            .setValue method

        Example:      
            describe('User visits root', () => {
                describe('without existing poems', () => {
                    it('page starts blank', () => {
                        browser.url('/');
                        assert.equal(browser.getText('#poems'), '');    // to verify that the element with the ID poems is empty.
                    });
                });
            });

        > npm init
        > npm i chai mocha webdriverio -D
        > npm i express

    -------------------- Server Testing with TDD --------------------
    Server tests are commonly used to test API responses, but we also use server tests for any server response 
    that our application relies on. This can include checking status codes and error messages.
    
    Technologies: 
        - Chai
        - jsdom
            jsdom library allows us to select elements of the DOM and check relationships and content. 
            'parseTextFromHTML' helper function
        - SuperTest
            fn 'request' is actually a reference to the SuperTest library

    Async / Await:
    const foo = async () => {
        console.log(await someAsyncThing());
        return true;
    }
    foo();

    const request = require('supertest');
    const app = require('../../app');
    describe('the homepage', () => {
        it('returns the correct content', async () => {
            const response = await request(app).get('/').send();
            console.log(response.text);
        });
    });

    In general, it is up to the developer to make a judgement call on how in depth to write a test.

    Status Codes:
    assert.equal(response.status, 200);

    Response Content:
    “Happy Path” — expected use cases of our application
        response.text = '<div><div id="my-name">My Name</div></div>';
        assert.include(parseTextFromHTML(response.text, '#my-name'), "My Name"); //True
    “Sad Path” — unexpected or invalid use of our application
        assert.notInclude(parseTextFromHTML(response.text, '#my-name'), "Your Name"); //True

    Templating library like 'Handlebars' to separate the HTML view from the JavaScript controller.
    /views/profile.handlebars
        <h1 id="welcome-message">Welcome {{ username }}!</h1>
    /routes/profile.js
        res.render('profile', {username})
        // instead of res.send('<h1 id="welcome-message">Welcome ' + username + '!</h1>');

    API Errors:
    We need to make sure our server properly handles invalid passwords, form field errors, etc.


    -------------------- Model Testing with TDD --------------------
    Mongoose is a JavaScript library that provides methods to interact with a MongoDB database. 
    Mongoose translates JavaScript objects (JSON) to BSON data in a MongoDB database, and vice versa.

    Mongoose Schema:
    const poemSchema = new mongoose.Schema({
        title: String
    })

    Mongoose provides data types:
        - string, 
        - integer, 
        - boolean,  
        - array
        - timestamp
        - Object ID

    Mongoose has several built-in validators https://mongoosejs.com/docs/validation.html:
        - required: true
        - required: 'Title is required!'

    const Poem = mongoose.model('Poem', poemSchema);    // mongoose.model(modelName, schema)

    Mongoose supports the creation of methods on both instances of documents and collections of documents:
        .statics() adds static “class” methods to the model.
        .methods() adds an instance method to documents.


    Testing: Model layer 
    Tools: Mocha test framework and the Chai assertion library.

    Methods. Mongoose schemas support:
        - static:   methods called by a model. They typically operate on a collection of documents (instances of the model).
        - instance: methods called by an instance of a model. They typically operate on the document (model instance) itself.

        
************************************************************************************************
************************************************************************************************
************************************************************************************************