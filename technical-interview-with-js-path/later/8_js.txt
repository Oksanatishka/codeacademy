TECHNICAL INTERVIEWS: WHITEBOARDING
Introduction
Aspiring developers must pass a technical interview to be hired as a professional. These interviews evaluate the candidate’s ability to write code, articulate their thought process, and problem solve in a timed environment.

Technical interviews take many forms: writing code alongside an employee of the company, testing online with a third-party service, take-home challenges spanning several days, and more!

A whiteboarding technical interview requires the interviewee to plan and code the solution by hand. The candidate relies on their ability to communicate without the assistance of a text editor or web browser.

This lesson covers strategies to improve performance in a whiteboarding interview. Each exercise features a step in the interview with a video demonstration of the technique.

The steps are:

Clarify the Problem
Create Inputs
Outline the Solution
Code the Solution
Test the Solution
Analyze the Solution
Instructions
Whiteboarding does not use a text editor, so this lesson will ask you to follow along with a pen and paper.

Grab a notebook and something to write with before moving forward!
--------------------------------------------------------------------------------------------------
Clarifying the Problem
Whiteboarding interviews begin with a problem from the interviewer. The interviewee must be confident they understand the dimensions of the problem!

Software development is full of ambiguity. Programming requires concrete deliverables, but company needs can be murky. Even when the need is clear, a feature could have dozens of possible implementations. The ability to clearly define a problem is an important skill to demonstrate.

When the interviewer presents their technical question, repeat the question back to the interviewer in your own words. This gives you a moment to think and will resolve any glaring misunderstandings.

Once you’ve repeated the question, ask every clarifying question that comes to mind.

Assumptions must be communicated to the interviewer so there is agreement on the scope of the problem.

For example, if asked:
Write a function that returns duplicate characters in string.

Here are some questions which may come to mind:

What is the desired return value?
True|False, a list of characters, or …?
Do punctuation and spaces count as “characters”?
Should case be considered?
are "a" and "A" duplicates?
Should we be checking for Unicode characters?
Can we assume it’s a 26 character alphabet?
Instructions
We’ll apply these steps to a single problem through the rest of the lesson.

Given a list of numbers, return whether the list contains Pythagorean Triplets.
Rephrase this problem in your own words and write that down.

Then, write down every question or assumption you have.

Watch the video to see how we clarified this question.
-------------------------------------------------------------------------------------------
Producing Inputs and Finding Edge Cases
When the question is clear, we then produce concrete inputs and outputs. These inputs guide a solution for the remainder of the interview so write them on the board!

You may still be unclear how to solve the problem in code, but it’s certain that given an input, X, your function will produce an output, Y.

Make one input the happy path: input that reflects a common scenario.

For example, you’re asked to write a function which capitalizes the first letter of an input string.

A good input could be "apple", which returns "Apple" because this demonstrates the function’s purpose.

If the input were "Apple", it would return "Apple". That’s correct but less informative.

Also think about edge cases, or inputs which do not reflect a common scenario and may cause problems.

For the capitalization function, what should you return if given None as input? Or a number?

Instructions
Write inputs and outputs for the Pythagorean Triplet problem.

Try to give yourself a few different cases.

Watch the video to see how we made inputs/outputs.
-------------------------------------------------------------------------------------------
Writing the Outline
It’s time to start breaking down the problem by category.

Given a question which requires the use of a stack, what do you know about stacks? Have you encountered other problems that use stacks and how were they solved?

Is this a searching question? Can you sort the input and will that help? Does this problem sound like it can be modeled as a graph, with vertices and connected edges?

Understanding the applications of different data structures is very useful! The more questions you practice, the more you will be able to see patterns between problems.

This step varies the most because it requires details of the specific problem, but regardless of the question make certain you are communicating with the interviewer as a potential co-worker. Show them your thought process!

During this step, the interviewer may make suggestions on how to proceed. Acknowledge the interviewer and incorporate their suggestions into your approach.

Don’t disregard their input! It gives the impression you would be difficult to work with on the job.

When you and the interviewer are satisfied with a workable solution, write the steps next to your input. Follow these steps as you write code on the board.

Instructions
Come up with an outline of how to solve the Pythagorean Triplet problem.

Don’t worry about efficiency, just aim for high-level steps which will produce the correct output.

Watch the video when you’re ready to move on.

-------------------------------------------------------------------------------------------
Coding the Solution
We’ve finally come to the portion where you’ll write some code! Previous steps improve your odds for success because you have an outline and clear inputs for testing.

Writing code on the board is a collaborative process. Refer to your outline and explain the step you’re implementing.

The goal is to be facing the interviewer when talking through the implementation and facing the board when you’re writing the code.

Try to avoid writing code in silence or narrating at a low level like “for… i… in… range… length of the list… colon” when writing for i in range(len(input_list)):.

When you’re finished with the implementation, look it over for any mistaken syntax or logical errors.

Instructions
Code the solution to the Pythagorean Triplets problem by writing it out on paper. Use your outline from the previous exercise as a guide.

Before writing each step on paper, say what you will do out loud. Better to practice by yourself than in a real interview!

-------------------------------------------------------------------------------------------
Testing with Inputs
With a working implementation on the whiteboard, use the test inputs to walk through the evaluation of your code.

Write out any temporary variables on the board and update them when they change during execution.

This is another opportunity to showcase your communication skills, and will help you catch any logical errors which you may not have noticed in earlier steps.

If you catch an error, don’t panic! Mistakes happen. Explain the issue and talk through what you can do to fix the bug.

Your interviewer may want to see you write the correction or they may be satisfied with the explanation.

Instructions
Use your test inputs and implementation to talk through your solution.

Again, say each line aloud so you become more comfortable speaking about the code you’ve written.

Track the variables used and update them as you go.

-------------------------------------------------------------------------------------------
Analyzing Time and Space Complexity
You’re satisfied with your implementation and you’ve demonstrated how it works, but you’re not quite done.

Analyze the time and space complexity of the solution. With this step you are demonstrating that you care about the efficiency of your code.

Explain your code’s big O notation. If you can optimize to a more efficient runtime, explain how that would work. If you can’t optimize, explain why it’s not possible.

Instructions
Talk through the big O time and space complexity of your solution.
-------------------------------------------------------------------------------------------
Review
Technical interviews judge the candidate’s ability to perform technical aspects of the job. Whiteboarding is a type of technical interview which requires the candidate to code a solution without the assistance of a text editor.

Coding an efficient solution is important, but the ultimate goal as an interviewee is to convince the interviewer you would be a desirable co-worker.

A desirable co-worker is able to articulate their thought process and collaborate without friction.

Our whiteboarding strategies revolve around communication at every step.

The steps are:

Clarify the Problem
Create Inputs
Outline the Solution
Code the Solution
Test the Solution
Analyze the Solution
Instructions
Practice makes perfect!

Run through these steps with a new practice problem:

Write a function which prints every number from 0 up to the given input. If divisible by 3, print "Fizz" instead of the number. If divisible by 5, print "Buzz". If input is divisible by 3 AND 5, print "FizzBuzz".
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

Sieve of Eratosthenes
In this interactive article, implement the classic Sieve of Eratothenes algorithm for finding prime numbers.

The Sieve of Eratosthenes is one of the oldest-known algorithms, and it’s still helpful for deriving prime numbers! The algorithm is attributed to Eratosthenes, a Greek mathemetician born in the third century BCE.

Eratosthenes

The sieve provides a set of steps for finding all prime numbers up to a given limit. In this article, we’ll cover implementing the Sieve of Eratosthenes in JavaScript. As a reminder, a prime number is a positive number with no divisors but 1 and itself. 2, 3, 11, and 443 are all prime numbers.

Sieve Implementation
The sieve works by first assuming that all numbers from

\{2,\dotsc,n\}{2,…,n}
are prime, and then successively marking them as NOT prime.

The algorithm works as follows:

Create a list of all integers from 2 to n.
Start with the smallest number in the list (2, the smallest prime number).
Mark all multiples of that number up to n as not prime.
Move to the next non-marked number and repeat this process until the entire list has been covered.
When the steps are complete, all remaining non-marked numbers are prime.

Example
If we wanted to find all prime numbers less than or equal to 10, we would:

Start with a list where all are assumed to be prime:

2 \quad 3 \quad 4 \quad 5 \quad 6 \quad 7 \quad 8 \quad 9 \quad 102345678910
Starting with 2, mark all multiple up to 10 as NOT prime:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad 9 \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	 9 
10
 
Move to the next non-marked number, 3, and mark its multiples as NOT prime (6) is already marked:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad \cancel{9} \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	  
9
​	  
10
 
Continue marking, starting with every non-marked number (in this case, all multiples of 5 are already marked, and 7‘s first multiple is out of range). This means that we have now found all primes up to 10:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad \cancel{9} \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	  
9
​	  
10
 
This animation shows the whole process for primes from 1 to 100:


Implementation Steps in JavaScript
There are many possible ways of implementing this algorithm in JavaScript. We’ll outline a basic approach here and then walk through it step-by-step.

Create an array of all integers from 2 to n
Set all elements of the array to true
Starting with 2, iterate through the array. If the current element is true, it is still considered prime. Since we know that all multiples of that number are NOT prime, iterate through all multiples of that number up to n and set them equal to false
Change the current element to the next non-false index.
Return the corresponding number value for any element still marked as prime (value of true).
If you’d like to try your hand at implementing the algorithm using these steps, jump to the complete algorithm code block below. Otherwise, we’ll do walk through a step-by-step breakdown below.

Step One: Create the Array
First, we’ll create the array. In this case, we’ll create an array to represent all numbers up to the input limit, but we’ll use the array index to represent the number, and its value (true/false) to represent whether it is prime or not. The original algorithm said to use an array of 2, ..., n, but since we’re using indices to represent the actual number, we’ll start the array from 0 and essentially ignore the values of array[0] and array[1].

For example, after running our sieve, an array representing the primes up to 7 would look like this, with elements at [2], [3], [5], and [7] marked true:

[false, false, true, true, false, true, false, true]
Fill in the blanks of the sieveOfEratosthenes() function to create an array with the correct size and use the correct Array method to fill it with the value true. Mark the numbers 0 and 1 as non-prime.

const sieveOfEratosthenes = (limit) => {
  const output = new Array().();
	output[0] = ;
	output[1] = ;
}
fill
false
2
limit
fillArray
limit + 1
true
false
Click or drag and drop to fill in the blank

Step Two: Iterate
Now we’ll implement the bulk of the algorithm to iterate and mark numbers as non-prime. We’ll do this in two steps:

Create an outer loop to iterate from 2 to the limit.
Inside, check if the current number is still marked prime. If it is, we’ll mark all its multiples using another loop.
Implement the non-prime marking phase of the Sieve of Eratosthenes. For each number from 2 to the limit, check if it has not been already marked as non-prime. If it has not, mark all its multiples as non-prime.

const sieveOfEratosthenes = (limit) => {
  const output = new Array(limit + 1).fill(true);
  output[0] = false;
  output[1] = false;

  for (let i = ; i <= ; ) {
    if (output[i] === ) {
      for (let j = ; j <= limit; ) {
        output[j] = ;
      }
    }
  }
}
i++
false
i
true
i * 2
j = j + i
2
j++
limit
i = i * i
0
true
Click or drag and drop to fill in the blank

Step Three: Return Values
Now it’s time to pare down our array and only return the actual primes. There are many ways to do this, so we’re going to let you figure out an approach to this part of the algorithm isolated from the rest of the code.

Hints
Complete the findTrueIndices() fuction. It should have a single parameter (an array), and return a new array of all indices in the input that are true.

For instance,

[false, false, true, true, false, true, false, true]
should return [2, 3, 5, 7].

You can assume that all array elements will be either true or false.

1234567891011
const findTrueIndices = (arr) => {
  
}


const test = findTrueIndices([false, false, true, true, false, true, false, true]);
// should return [2, 3, 5, 7]
console.log(test);


 
Complete Algorithm
Now it’s time to implement the complete algorithm! Try your hand at it and test it with multiple inputs (it may take a while to run if you call it with a very large input).

Implement the Sieve of Eratosthenes algorithm in JavaScript!

You can assume that your function is always called with a number. However, it should always return an array, even if there are no primes, so make sure to handle any edge case(s).

We’ve given you an example in the workspace along with the expected result. Run your code as you implement to see the results.

12345678910
const sieveOfEratosthenes = () => {
  
}

const test = sieveOfEratosthenes(13);
// should return [2, 3, 5, 7, 11, 13]
console.log(test);

// Leave this line for testing:
module.exports = sieveOfEratosthenes;
 
Optimizations
There are several small optimizations that can be made to the basic implementation of the sieve to remove duplicate checks for prime-ness.

End Boundary
In our basic implementation, the outer loop iterated from 2 to n. Because the inner loop marks multiples of a base value, we only need to check individual numbers lower than the square root of n. Consider the example of a limit of 10:

First, all multiples of 2 are marked:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad 9 \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	 9 
10
 
Then, all multiples of 3 are marked:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad \cancel{9} \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	  
9
​	  
10
 
4 is less than the square root of 10 (approximately 3.16), so we can break. If you look at the previous step, all non-prime numbers have indeed already been marked.

First Multiple
In our basic implementation, the inner loop started checking multiples at 2 times the current number. We can skip a few checks starting the checks at current2.

Consider the example of a limit of 10 again:

First, all multiples of 2 are marked:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad 9 \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	 9 
10
 
Then, all multiples of 3 are marked, but we can skip 6 (3 * 2) because it’s already been marked. Instead we start at 32, 9:

2 \quad 3 \quad \cancel{4} \quad 5 \quad \cancel{6} \quad 7 \quad \cancel{8} \quad \cancel{9} \quad \cancel{10}23 
4
​	 5 
6
​	 7 
8
​	  
9
​	  
10
 
We’ve now completed the check with one less comparison.

Pre-mark All Even Numbers
This optimization comes in when building the initial array. There’s no need to ever check even numbers after 2, since they will never be prime, so they can all be marked as non-prime initially.

These optimizations may seem small when dealing with a limit of 10, but they can significantly speed up the algorithm with larger limits.

Complexity
The complexity of the Sieve of Eratosthenes with optimizations is

O(n\log{}(\log{}n))O(nlog(logn))
There are two operations to take into account: the creation of the array and the incrementing and multiple-marking loops.

Creation happens in O(n) time, since it creates an element for each number from 2 to n.

Multiple marking happens in O(n log log n) time. The reasons for this come down to some complex math, but briefly:

The number of times you mark a non-prime number is

\frac{n}{2} + \frac{n}{3} + ... \frac{n}{\sqrt{n}} 
2
n
​	 + 
3
n
​	 +... 
n
​	 
n
​	 
It begins with n / 2 because initially all multiples of 2 are marked as non-prime (this will happen 50 times with a limit of 100, as each even number is marked). This process continues up until the square root of n. Through some fancy mathematical proofs, this works out to an overall time complexity of

O(n\log{}(\log{}n))O(nlog(logn))
since this is larger than the O(n) array-creation time.

Conclusion
The Sieve of Eratosthenes is a millennia-old algorithm, so there are some more improvements and more advanced methods for finding primes invented since its discovery, but it’s still a great way to generate lists of prime numbers. Included below is our sieve code including optimizations:

const sieveOfEratosthenes = (limit) => {
  // Handle edge cases
  if (limit <= 1) {
    return [];
  }
  // Create the output
  const output = new Array(limit + 1).fill(true);
  // Mark 0 and 1 as non-prime
  output[0] = false;
  output[1] = false;

  // Iterate up to the square root of the limit
  for (let i = 2; i < Math.pow(limit, 0.5); i++) {
    if (output[i] === true) {
      // Mark all multiples of i as non-prime
      for (let j = Math.pow(i, 2); j <= limit; j = j + i) {
        output[j] = false;
      }
    }
  }

  // Remove non-prime numbers
  return output.reduce((primes, current, index) => {
    if (current) {
      primes.push(index);
    }
    return primes
  }, []);
}
-------------------------------------------------------------------------------------------
Capturing Rainwater
Learn JavaScript implementations of the capturing rainwater interview question.

A common interview question involving arrays is the “capturing rainwater” problem (sometimes referred to as the “trapping rainwater” problem).

The Problem
Imagine a very heavy rainstorm over a highway that has many potholes and cracks. The rainwater will collect in the empty spaces in the road, creating puddles. Each puddle can only be as high as the road around it, as any excess water will just flow away.

The capturing rainwater problem asks you to calculate how much rainwater would be trapped in the empty spaces in a histogram (a chart which consists of a series of bars). Consider the following histogram:

histogram without water
This can be represented in JavaScript as an array filled with the values [4, 2, 1, 3, 0, 1, 2]. Imagine that rainwater has fallen over the histogram and collected between the bars. Here’s how the previous histogram would look filled with water:

histogram with water
Like with the road, the amount of water that can be captured at any given space cannot be higher than the bounds around it. To solve the problem, we need to write a function that will take in an array of integers and calculate the total water captured. Our function would return 6 for the histogram above. There are multiple ways to solve this problem, but we are going to focus on a naive implementation and an optimized implementation.

The Concept
The foundation to all the solutions for this problem is that the amount of rainwater at any given index is the difference between the lower of highest bars to its left and right and the height of the index itself:

waterAtIndex = Math.min(highestLeftBound, highestRightBound) - heightOfIndex;
Look at the histogram again. The amount of water at index 4 is 2. This is because its highest left bound is 3 (element at index 3), and its highest right bound is 2 (element at index 6). The lower of these two values is 2, and when we subtract the index’s height of 0, we get our answer of 2.

The Naive Solution
The naive solution to the problem is to:

Traverse every element in the array
Find the highest left bound for that index
Find the highest right bound for that index
Take the lower of those two values
Subtract the height of that index from that minimum
Add the difference to the total amount of water
In JavaScript this looks like this:

function naiveSolution(heights) {
  let totalWater = 0;
  for (let i = 1; i < heights.length - 1; i++) {
    let leftBound = 0;
    let rightBound = 0;
    // We only want to look at the elements to the left of i, which are the elements at the lower indices
    for (let j = 0; j <= i; j++) { 
      leftBound = Math.max(leftBound, heights[j]);
    }
    // Likewise, we only want the elements to the right of i, which are the elements at the higher indices
    for (let j = i; j < heights.length; j++) {
      rightBound = Math.max(rightBound, heights[j]);
    }
    totalWater += Math.min(leftBound, rightBound) - heights[i];
  }
  return totalWater;
}
While this is a functional solution, it requires nested for loops, which means it has a big O runtime of O(n^2). Let’s look at a solution with a more efficient runtime.

The Optimized Solution
The previous solution had a quadratic runtime, but it’s possible to solve this problem in O(n) time by using two pointers. The pointers will start at each end of the array and move towards each other. The two-pointer approach is a common approach for problems that require working with arrays, as it allows you to go through the array in a single loop and without needing to create copy arrays.

We’ll start by creating the following variables:

totalWater = 0
leftPointer = 0 
rightPointer = heights.length - 1
leftBound = 0
rightBound = 0
leftPointer and rightPointer will start at the beginning and end of the array, respectively, and move towards each other until they meet. The algorithm is as follows:

while leftPointer < rightPointer
  if the element at leftPointer <= rightPointer
    if the element is larger than leftBound, set leftBound to the element
    add the difference between leftBound and the element at leftPointer to totalWater
    move leftPointer forward by one
  else
    if the element is larger than rightBound, set rightBound to the element
    add the difference between rightBound and the element at rightPointer to totalWater
    move rightPointer back by one 

return totalWater
Using the pseudocode above, finish the efficientSolution() function. Make sure you run it on the given array first! (If you run into an infinite loop, you can refresh the page to stop it.)

1234567891011121314
function efficientSolution(heights) {
  let totalWater = 0;
  let leftPointer = 0;
  let rightPointer = heights.length - 1;
  let leftBound = 0;
  let rightBound = 0;
  
}

const testArray = [4, 2, 1, 3, 0, 1, 2];

 
Congrats! You created the optimized solution to the capturing rain water problem. This solution has a linear time complexity because it only loops through the array one time. Additionally, both this and the naive solution have a constant space complexity of O(1). There are other solutions that have also have linear time but then have a linear space complexity, like a solution that uses arrays to keep track of the left and right bounds. How do you think that solution would work?

Takeaway: The Two Pointer Approach
The two-pointer approach is one that you can, and should, use in many interview questions. When you see a problem that requires you to iterate through an array (or string), take a moment and think about if it would be possible to iterate through it in sections at the same time instead of in separate loops. Common problems that can be solved using the two-pointer technique are the two sum problem (finding two numbers in an array that sum to a specified number) and reversing the characters in a string.
-------------------------------------------------------------------------------------------
Sorting with Custom Comparator Functions
Learn about internal sorting and create a comparator function in JavaScript.

The Array Sort Method
There are many algorithms to sort arrays, including bubble sort, merge sort, and quicksort. The JavaScript array object type actually has a .sort() method that will sort the array it’s called on in place and return the sorted version.

Run the code below to see how the internal .sort() method works.

12345
const array1 = [10, 43, 5, 0, 4, 3, 2, 1, 11];
console.log(array1.sort());

const array2 = ['f', 'e', 'd', 'a', 'h', 'b', 'actual', 'aardvark'];
console.log(array2.sort());
 
As you can see, the internal .sort() method does return an altered array that is more sorted than before, but it’s not what we would expect to see. The numbers are ordered by the first digit, so while 1 comes before 2 (as expected), 10 also comes before 2 since its first digit is a 1. The same pattern can be seen in the sorting of the strings, where it’s sorted according to the first character. This is because .sort()‘s default comparator converts the values in the array to strings and then compares them lexically.

But what if we want to sort the array another way? Yes, it’s possible to use one of the sorting algorithms listed above, but the .sort() method will actually allow us to tell it how we want it to compare the elements in the array.

Custom Comparators
We can pass a custom comparator function that we have created to the .sort() method in order to sort the array in any way we desire:

myArray.sort(myComparatorFunction);
The comparator function will compare two elements in the array and return a value that .sort() will use to determine the sorting order. The function should take two arguments, usually named a and b:

const myComparatorFunction = (a, b) => {

}
There are three possible categories of return values:

A value less than zero, which means a will be sorted at a lower index than b
A value greater than zero, which means b will be sorted at a lower index than a
The value zero, which means the two elements were equal and won’t be moved
Now that we’re familiar with the idea of a comparator function, let’s take a look at some examples.

Sorted in Ascending Order
We’re going to start with one of the most intuitive orderings: ascending. This sort will yield the same results as using a sorting algorithm like quicksort or merge sort. The first step is to create the comparator function. Given inputs a and b, the pseudocode is as follows:

if a is less than b
  return negative number
if a is greater than b
  return positive number
if a is equal to b
  return 0
Using the pseudocode above, create the ascendingOrder() comparator function.

12345678910
const ascendingOrder = (a, b) => {
  
}

// Use this array to test your code:
const testArray = [10, 43, 5, 0, -2, -20, 4, 3, 2, 1, 11];
testArray.sort(ascendingOrder);
console.log(testArray);


 
While you could create the ascendingOrder() function using three if statements, you could optimize it by simply returning a - b. This will return a negative number if a is smaller, a positive number if b is smaller, and zero if they are equal. Likewise, if you wanted to sort an array in descending order, the function could simply return b - a.

Sorting by Length
Let’s try sorting elements by their length, from the shortest element to the longest.

If we want to sort an array by each element’s length in ascending order, we should return _____ when a is shorter than b, and _____ when a is longer than b.


1, -1


-1, 1

We have handled situations when a and b have different lengths, but what if they have the same length? Following the logic we currently have, the function would place each group of elements with the same length together in the same order they were in the original array. It would be nice to have those elements sorted in some way, and we can reuse our ascendingOrder() function from above for that.

Create the sortByLength() comparator function. (Remember that you can use someVariable.length to access an array or string’s length!)

1234567891011121314151617
const sortByLength = (a, b) => {
  
}

const ascendingOrder = (a, b) => {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {

 
How do you think you would change the function to sort the array from the longest elements to the shortest?

Explicit Ordering
Let’s try a more complicated custom comparator. Given an input array, we want to sort the array given to an explicit order. If elements aren’t in the given explicit order, put them at the back in the same order they appeared in. For example, given:

const inputArray = ['a', 'b', 'c', 'd', 'e', 'f', 'n', 'y', 'g'];
const order = ['a', 'n', 'd', 'y'];
the comparator function explicitSort(inputArray, order) should return:

['a', 'n', 'd', 'y', 'b', 'c', 'e', 'f', 'g']
In order to do this, we are going to use an explicitSortWithComparator() function that takes inputArray and order as parameters, and has an internal explicitComparator() function, which is what will take a and b. At the end of explicitSortWithComparator(), we will call .sort(explicitComparator) on inputArray and return the result.

The explicitComparator() function will find the indices of a and b in the order array (if they exist) and return the difference between them:

indexA and indexB are initialized to the length of the order array
if a is in order
  indexA = a's index in order
if b is in order
  indexB = b's index in order
return indexA - indexB
Finish the explicitComparator() function to complete the explicitSortWithComparator() function. Remember that you can use someArray.indexOf(someElement) to find the index of an element in the array, and someArray.includes(someElement) to see if that element exists in the array.

1234567891011121314
const explicitSortWithComparator = (inputArray, order) => {
  
  const explicitComparator = (a, b) => {
    // Write your code here:
    
  }
  
  return inputArray.sort(explicitComparator).slice();

 
Time and Space Complexities
The time and space complexities of your custom comparator functions will vary depending on your implementations, but what about the time and space complexities of JavaScript’s internal .sort() method? That depends on the length of the array you want to sort. If the array has 10 or fewer elements, then the method will use insertion sort, with a time complexity of O(n^2) and a space complexity of O(1). If the array is longer, then the method will use quicksort, giving it a time complexity of O(n log n) and a space complexity of O(log n).
-------------------------------------------------------------------------------------------
Introduction To Dynamic Programming in JavaScript
Learn how to use dynamic programming to solve complex recursive problems.

Dynamic Programming is a programming technique used to solve recursive problems more efficiently. Let’s take a look at a simple algorithm that can get computationally complex very quickly, and then let’s use dynamic programming to increase its efficiency.

Fibonacci
The Fibonacci series is a classic mathematical series in which the next number is calculated as the sum of the previous two numbers:

0, 1, 1, 2, 3, 5, 8, 13, 21, etc.
It can be calculated iteratively but summing the two previous numbers, or the nth Fibonacci number can be calculated recursively:

function fib(n)
  if n is 1 or 0:
    return n
  else
    return fib(n - 1) + fib(n - 2)
This technique breaks up calculating the nth number into many smaller problems, calculating each step as the sum of calculating the previous two numbers.

Although this technique will certainly work to find the correct number, as n grows, the number of recursive calls grows very quickly. Let’s visualize all the function calls if we were to calculate the fourth Fibonacci number:

fib(4) -> fib(3) + fib(2)
  fib(3) -> fib(2) + fib(1)
    fib(2) -> fib(1) + fib(0)
  fib(2) -> fib(1) + fib(0)
As you can seefib(2) is called twice, fib(1) is called three times. If n were larger than 4, you’d see these numbers of calls get high very quickly. For instance, to calculate the 10th number, we’d make 34 calls to fib(2) and 177 total function calls! Why do we need to call the same function multiple times with the same input?

We don’t! We can use a technique called memoization to cut down greatly on the number of function calls necessary to calculate the correct number.

Memoization
Memoization is a specialized form of caching used to store the result of a function call. The next time that function is called, instead of running the function itself, the result is used directly. Memoization can result in much faster overall execution times (although it can increase memory requirements as function results are stored in memory).

Memoization is a great technique to use alongside recursion. The memo can even be saved between function calls if it’s being used for common calculations in a program.

Memoizing Fibonacci
In the previous example, many function calls to fib() were redundant. Let’s memoize it in order to speed up execution.

To begin, we’ll use a plain JavaScript object to store the memoized values. We’ll set keys using n and values to store the result of that Fibonacci number. Then, whenever we need to calculate a number, if it’s already been calculated, we can retrieve the value from the object in O(1) time.

const memo = {};
In pseudocode, our approach to memoization will look something like this:

Create a memo object

function fibonacci(n)
  if n key exists in memo object
    return memo[n]
  else
    calculate current fibonacci number
    store value in memo
    return value
Let’s implement it in JavaScript!

Create a memoized fibonacci() function. This function should return the nth Fibonacci number.

Note: To avoid an infinite loop, either handle the edge case of negative numbers in your function, or don’t call it using negative numbers.

123456789
const memo = {};

const fibonacci = num => {
  
}

// Test your code with calls here:
console.log(fibonacci(20));
console.log(fibonacci(200));
 
Great job! Let’s look at the total number of function calls now. Earlier, it took 177 function calls to calculate the 10th number. Now, it should only be 19.

Conclusion
Dynamic programming and memoization are great techniques breaking up complex recursive problems into smaller chunks. They are especially useful when tackling problems that involve combinations. For example, if I asked you to calculate the total number of ways to get four dice rolls to sum to 13, you could imagine breaking that into multiple parts. You could split 13 into 6 and 7 and then find all the combinations of two rolls that would match each one of these. As you went down each path, you’d probably start seeing a lot of similar calculations, and memoization would help you reduce the number of overall function calls by storing intermediate values.
-------------------------------------------------------------------------------------------
The Knapsack Problem
Recursive and dynamic programming approaches to the classic knapsack problem in JavaScript.

Imagine that you’re a thief breaking into a house. There are so many valuables to steal - diamonds, gold, jewelry, and more! But remember, you’re just one person who can only carry so much. Each item has a weight and value, and your goal is to maximize the total value of items while remaining within the weight limit of your knapsack. This is called the knapsack problem and is commonly used in programming interviews. We will solve this problem in two ways: recursively, and using dynamic programming.

The Problem
The first step to solving this problem is to understand the parameters involved. You will be given:

the total amount of weight you can carry (weightCap)
the weights of all of the items in an array (weights)
the values of all of the items in an array (values)
Your function should return the maximum value that you will be able to carry.

An Example
Let’s say that you have a knapsack that can only carry 5 pounds, and the house you’re robbing has three items that you want to steal:

A ring that weighs 1 pound with a value of $250
Earrings that weigh 3 pounds with a value of $300
A necklace that weighs 5 pounds with a value of $500
This information can be summarized as follows:

weightCap = 5 
weights = [1, 3, 5]
values = [250, 300, 500]
You have four possible ways to fill your knapsack:

Take only the ring, giving you $250
Take only the earrings, giving you $300
Take only the necklace, giving you $500
Take the ring and the earrings, giving you $550
Since the ring and the earrings have a combined weight of 4 pounds, taking both gives you the maximum value while staying within your weight capacity. Now that you’re familiar with the problem, let’s take a look at two different approaches to solving it!

The Recursive Solution
The brute force solution to this problem is to look at every subset of the items that has a total weight less than weightCap. Then you simply take the maximum of those subsets, giving you the optimized subset with the highest value possible.

You will need an additional parameter, i, that tells us where we are in the list of items. With each step, we will break the problem down into subproblems, and compare them to find the maximum value. There are three possibilities for every call of the function:

weightCap or i are zero, meaning the knapsack can hold no weight, or there are no more items to look at. In either case, we return 0.
The weight of the item we’re looking at exceeds weightCap, in which case we just move on, calling the function on the next item.
If neither of the above are true, that means we have to consider whether or not the item we are at (i) should be included in the optimal solution.
Steps 1 and 2 from above can be solved as follows:

const recursiveKnapsack = function(weightCap, weights, values, i) {
  if (weightCap === 0 || i === 0) {
    return 0;
  } else if (weights[i - 1] > weightCap) {
    return recursiveKnapsack(weightCap, weights, values, i - 1);
  } 
};
For step 3, we need to look at both situations and determine if we want to include this item in our optimized solution or not.

Fill in the code to solve step 3 and finish the recursiveKnapsack() function.

const recursiveKnapsack = function(weightCap, weights, values, i) {
  if (weightCap === 0 || i === 0) {
    return 0;
  } else if (weights[i - 1] > weightCap) {
    return recursiveKnapsack(weightCap, weights, values, i - 1);
  } else {
    const includeItem = values[i - 1] + recursiveKnapsack(, weights, values, i - 1);
    const excludeItem = recursiveKnapsack(, weights, values, i - 1);
    return (includeItem, excludeItem);
  }
};
weightCap - weights[i - 1]
Math.max
Math.min
weightCap
Click or drag and drop to fill in the blank

While this recursive solution works, it has a big O runtime of O(2^n). In the worst case, each step would require us to evaluate two subproblems, sometimes repeatedly, as there’s overlap between subproblems. We can drastically improve on this runtime by using dynamic programming.

The Dynamic Programming Approach
The knapsack problem is suited for dynamic programming because memoization will allow us to store information instead of making duplicate calls. We will store this information in a two-dimensional array that has a row for every item and weightCap + 1 number of columns where each element in the 2D array (matrix) represents a subproblem. The element at the bottom right will be the optimal solution.

But what exactly do the rows and columns represent? The rows represent the items we have seen. So if we are row 4, then we have only seen the first 4 items, meaning the others aren’t being considered yet. The columns represent how much weight the knapsack can hold. If we are at column 7, then we are looking at a subset of the larger problem where our knapsack has a weight capacity of 7. The number stored inside matrix is the maximum value we can take given the weight capacity and number of items we have seen for that subproblem. By the time we get to the bottom right space in matrix, we have considered every possible subproblem and taken the maximum possible value.

There are some elements in the matrix that will be easy to fill. Every element in the zeroeth row represents a subproblem with 0 items to consider, so there is no value. Likewise, every element in the zeroeth column represents a subproblem where our knapsack has a capacity of 0, giving us no value to take. Because of this, we start by filling the zeroeth row and column with 0.

The pseudocode for the entire algorithm is as follows:

matrix = array with length equal to number of items
for every number of items you can carry (index):
  fill matrix[index] with an array of length weightCap + 1
  for every weight < weightCap (weight):
    if index or weight == 0:
      set element at [index][weight] to 0  
    else if the weight of element at index - 1 <= weight:
      find possible values of including and excluding the item
      set element at [index][weight] to max of those values
    else:
      set element at [index][weight] to element one above
return element at bottom right of matrix
Using the pseudocode above, complete the dynamicKnapsack() function.

123456789101112131415
const dynamicKnapsack = function(weightCap, weights, values) {
  const numItem = weights.length;
  const matrix = new Array(numItem);
  
  for (let index = 0; index <= numItem; index++) {
    matrix[index] = new Array(weightCap + 1);
    for (let weight = 0; weight <= weightCap; weight++) {

 
Congratulations! You have implemented the dynamic programming approach to the knapsack problem. This version has a big O runtime of O(index * weight) compared to the recursive implementation’s runtime of O(2^n). While this optimized runtime might seem worse using small cases, it is much more efficient as the parameters grow.

-------------------------------------------------------------------------------------------
Next Steps
Congratulations on completing Pass the Technical Interview with JavaScript! You’ve learned a lot of new data structures and algorithms and built them all in JavaScript from the ground up!

Next Steps
There’s lots more to practice when it comes to data structures and algorithms. As a developer, you’ll always want to use the best tool for the job, so you never have knowledge of too many data structures or algorithms. If you’re interested in continuing to practice and build your skills, consider investing in some of our suggestions below.

Additional Data Structures and Algorithms
We’ve covered a broad base of fundamental data structures, but there are many more advanced and specialized forms. Consider studying and building the following:

Tree-based data structures like the red-black tree, trie, or self-balancing binary tree
Binary and bitwise structures like bit fields and bitmasks
Consider looking into the following algorithms:

A*, a variation on Dijkstra’s algorithm.
Additional sorting algorithms like heapsort, shell sort, or radix sort
Additional pathfinding algorithms, such as the Lee algorithm for searching through mazes
String-searching and pattern-matching algorithms such as the Knuth–Morris–Pratt (KMP) algorithm
Extensions
In addition to building data structures and algorithms themselves, try applying them in new situations. Here are a few ideas to get you started

Alter the sorting algorithms that you built in this course so that they take a comparator function and can sort anything instead of just numbers.
Experiment with other hashing functions for your HashMap structure. Can you maximize the efficiency for different types of inputs with different hashing functions?
Projects
Besides learning new algorithms and data structures, one of the best ways to work on problem-solving is to build real-life projects. Consider building a project where using algorithms and data structures will be necessary in order to make the application efficient:

A dictionary search or spellchecker
A route-planning application
An application for pairing work partners based on their shared interests
A card game simulator in which you can shuffle the deck, maintain player hands, and keep track of the state of play
Practice
One of the best ways to prepare for an interview is to practice with a friend! Coding on a whiteboard with a time limit is not the most common or natural experience, so it’s good to build up your confidence by simulating the experience of a technical interview. Try different problems and interview styles: whiteboarding with pseudocode, whiteboarding in JavaScript, coding on a computer, pairing on a video call, and more.
